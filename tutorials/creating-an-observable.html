<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Creating an Observable from a Simulation &mdash; MDMC 0.2 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Selecting Fitting Parameters" href="selecting-fitting-parameters.html" />
    <link rel="prev" title="Running a Simulation in MDMC" href="running-a-simulation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> MDMC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pages/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/simulations.html">3. Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/parameter-refinement.html">4. Parameter Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/contributing.html">5. Contributing to MDMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="building-a-universe.html">Building an MDMC Universe</a></li>
<li class="toctree-l1"><a class="reference internal" href="read-configurations.html">Reading atoms from configuration files</a></li>
<li class="toctree-l1"><a class="reference internal" href="units.html">Units in MDMC</a></li>
<li class="toctree-l1"><a class="reference internal" href="applying-a-forcefield.html">Applying a <code class="docutils literal notranslate"><span class="pre">ForceField</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="solvating-a-universe.html">Solvating an MDMC Universe</a></li>
<li class="toctree-l1"><a class="reference internal" href="molecular-visualization.html">Molecular Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="running-a-simulation.html">Running a Simulation in MDMC</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Creating an Observable from a Simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Running-a-simulation">Running a simulation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#3D-surface-plotting">3D surface plotting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Calculating-S(Q,\omega)">Calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="#Other-observables">Other observables</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="selecting-fitting-parameters.html">Selecting Fitting Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="running-a-refinement.html">Running a Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="Argon-a-to-z.html">Argon A-to-Z</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/coding_standards.html">Coding Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/documentation.html">Documentation Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/management.html">MDMC Software Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/vscode.html">Debugging inside Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/recipes.html">Recipes for ‘simple’ additions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/developer/known_bugs.html">Known bugs and unimplemented features</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/common.html">common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/control.html">control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/gui.html">gui</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/readers.html">readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/refinement.html">refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pages/modules/trajectory_analysis.html">trajectory_analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">MDMC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Creating an Observable from a Simulation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/tutorials/creating-an-observable.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt .copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="Creating-an-Observable-from-a-Simulation">
<h1>Creating an Observable from a Simulation<a class="headerlink" href="#Creating-an-Observable-from-a-Simulation" title="Permalink to this headline"></a></h1>
<p>When running a refinement, MDMC makes quantitative comparisons between properties measured experimentally and calculated from MD simulations: within MDMC each of these properties is an <code class="docutils literal notranslate"><span class="pre">Observable</span></code>. Examples of these observables are the dynamic structure factor, <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span>, and the pair distribution function, <span class="math notranslate nohighlight">\(G(r)\)</span>.</p>
<p>Within a refinement, each <code class="docutils literal notranslate"><span class="pre">Observable</span></code> is calculated from MD automatically. However it is also useful to be able to calculate an <code class="docutils literal notranslate"><span class="pre">Observable</span></code> from an MD simulation and plot it, which is demonstrated in this tutorial.</p>
<p>This tutorial requires matplotlib to be installed:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">%</span><span class="k">matplotlib</span> notebook
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="o">%</span><span class="k">pip</span> install matplotlib
    <span class="k">try</span><span class="p">:</span>
        <span class="o">%</span><span class="k">matplotlib</span> notebook
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please restart the kernel so that matplotlib can be imported.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<section id="Running-a-simulation">
<h2>Running a simulation<a class="headerlink" href="#Running-a-simulation" title="Permalink to this headline"></a></h2>
<p>Below we setup and run a simulation of liquid argon so that we have a <code class="docutils literal notranslate"><span class="pre">CompactTrajectory</span></code> from which to calculate an <code class="docutils literal notranslate"><span class="pre">Observable</span></code>.</p>
<p><strong>As this is minimizing, equilibrating, and running a production run, this should take ~3 minutes to execute</strong>. Minimization lowers the potential energy of the simulated system by adjusting atomic positions. Running a simulation with <code class="docutils literal notranslate"><span class="pre">equilibration</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code> will not record a <code class="docutils literal notranslate"><span class="pre">CompactTrajectory</span></code>, and since we specified neither a thermostat or barastat for the simulation a Berendsen thermostat will be applied for the duration of the equilibration. It will not be present for the second
run, when the <code class="docutils literal notranslate"><span class="pre">CompactTrajectory</span></code> is recorded.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDMC.MD</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Build universe</span>
<span class="n">universe</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="mf">38.4441</span><span class="p">)</span>
<span class="n">Ar</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;Ar&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="c1"># Fill box with 1000 atoms, and hence atoms per AA^-3 density = 0.0176</span>
<span class="n">universe</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">Ar</span><span class="p">,</span> <span class="n">num_struc_units</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Universe contains </span><span class="si">{}</span><span class="s1"> Ar atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
<span class="n">Ar_dispersion</span> <span class="o">=</span> <span class="n">Dispersion</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">Ar</span><span class="o">.</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">Ar</span><span class="o">.</span><span class="n">atom_type</span><span class="p">),</span>
                           <span class="n">cutoff</span><span class="o">=</span><span class="mf">8.</span><span class="p">,</span>
                           <span class="n">vdw_tail_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">function</span><span class="o">=</span><span class="n">LennardJones</span><span class="p">(</span><span class="mf">1.0243</span><span class="p">,</span> <span class="mf">3.36</span><span class="p">))</span>

<span class="c1"># MD Engine setup</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span>
                        <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;lammps&quot;</span><span class="p">,</span>
                        <span class="n">time_step</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                        <span class="n">temperature</span><span class="o">=</span><span class="mf">120.</span><span class="p">,</span>
                        <span class="n">traj_step</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

<span class="c1"># Energy Minimization and equilibration</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">equilibration</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">12025</span><span class="p">)</span>
<span class="n">trajectory</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">trajectory</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Supported DL_POLY version 5.0
Universe created with:
  Dimensions       [38.44, 38.44, 38.44]
  Force field                       None
  Number of atoms                      0

Universe contains 1000 Ar atoms
LAMMPS (29 Sep 2021 - Update 3)
OMP_NUM_THREADS environment is not set. Defaulting to 1 thread. (src/comm.cpp:98)
  using 1 OpenMP thread(s) per MPI task
LAMMPS output is captured by PyLammps wrapper
LAMMPS (29 Sep 2021 - Update 3)
LAMMPS output is captured by PyLammps wrapper
OMP_NUM_THREADS environment is not set. Defaulting to 1 thread. (src/comm.cpp:98)
  using 1 OpenMP thread(s) per MPI task
Total wall time: 0:00:00
Simulation created with lammps engine and settings:
  temperature  120.0

</pre></div></div>
</div>
<section id="3D-surface-plotting">
<h3>3D surface plotting<a class="headerlink" href="#3D-surface-plotting" title="Permalink to this headline"></a></h3>
<p>Below we define a simple function for plotting 3D surfaces, which we will use for plotting the observables.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plot_surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
</section>
<section id="Calculating-S(Q,\omega)">
<h2>Calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span><a class="headerlink" href="#Calculating-S(Q,\omega)" title="Permalink to this headline"></a></h2>
<p>To see which observables can be calculated, use the <code class="docutils literal notranslate"><span class="pre">help</span></code> function to look at the observables module documentation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">MDMC.trajectory_analysis</span> <span class="kn">import</span> <span class="n">observables</span>
<span class="n">help</span><span class="p">(</span><span class="n">observables</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on package MDMC.trajectory_analysis.observables in MDMC.trajectory_analysis:

NAME
    MDMC.trajectory_analysis.observables - Modules calculating observables from molecular dynamics trajectories

DESCRIPTION
    Observables (/ indicates alias)
    -----------
    PDF / PairDistributionFunction
    DynamicStructureFactor / SQw
    CoherentDynamicStructureFactor / SQwCoherent / SQwCoh / SQw_coh
    IncoherentDynamicStructureFactor / SQwIncoherentSQwIncoh / SQw_incoh
    IntermediateScatteringFunction / FQt
    CoherentIntermediateScatteringFunction / FQtCoherent / FQtCoh / FQt_coh
    IncoherentIntermediateScatteringFunction / FQtIncoherentFQtIncoh / FQt_incoh

    Examples
    --------
    Observables can be instantiated using the names above. For instance an SQw
    observable can be instantiated using either of the aliases:

    .. code-block:: python

        from MDMC.trajectory_analysis import observables
        sqw = observables.SQw()                     # This line...
        sqw = observables.DynamicStructureFactor()  # ...is equivalent to this line

PACKAGE CONTENTS
    fqt
    fqt_coh
    fqt_incoh
    obs
    obs_factory
    pdf
    sqw

CLASSES
    MDMC.trajectory_analysis.observables.fqt.AbstractFQt(MDMC.trajectory_analysis.observables.sqw.SQwMixins, MDMC.trajectory_analysis.observables.obs.Observable)
        MDMC.trajectory_analysis.observables.fqt.FQt
        MDMC.trajectory_analysis.observables.fqt_coh.FQtCoherent
        MDMC.trajectory_analysis.observables.fqt_incoh.FQtIncoherent
    MDMC.trajectory_analysis.observables.obs.Observable(abc.ABC)
        MDMC.trajectory_analysis.observables.pdf.PairDistributionFunction
    MDMC.trajectory_analysis.observables.sqw.AbstractSQw(MDMC.trajectory_analysis.observables.sqw.SQwMixins, MDMC.trajectory_analysis.observables.obs.Observable)
        MDMC.trajectory_analysis.observables.sqw.SQw
        MDMC.trajectory_analysis.observables.sqw.SQwCoherent
        MDMC.trajectory_analysis.observables.sqw.SQwIncoherent

    CoherentDynamicStructureFactor = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    CoherentIntermediateScatteringFunction = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;FQt_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    DynamicStructureFactor = class SQw(AbstractSQw)
     |  A class for the total dynamic structure factor
     |
     |  Calculation is done in the respective FQt object, and this is
     |  just a reference to get the correct FQt object.
     |
     |  Method resolution order:
     |      SQw
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    class FQt(AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the total dynamic structure factor
     |
     |  Method resolution order:
     |      FQt
     |      AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;IntermediateScatteringFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    FQtCoh = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;FQt_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;FQt_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    FQtIncoherentFQtIncoh = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;IncoherentIntermediateScatteringFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    FQt_coh = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;FQt_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    FQt_incoh = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;IncoherentIntermediateScatteringFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    IncoherentDynamicStructureFactor = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_incoh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    IncoherentIntermediateScatteringFunction = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;IncoherentIntermediateScatteringFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    IntermediateScatteringFunction = class FQt(AbstractFQt)
     |  A class for containing, calculating and reading the intermediate scattering
     |  function for the total dynamic structure factor
     |
     |  Method resolution order:
     |      FQt
     |      AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;IntermediateScatteringFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution: Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: &#39;list[float]&#39;, resolution: MDMC.resolution.resolution.Resolution = None) -&gt; &#39;np.ndarray&#39;
     |      Calculates S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy: list of floats
     |          the list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution: Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t)
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculates the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          a single ``CompactTrajectory`` object.
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables: this is
     |      FQt, the intermediate scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;FQt&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;t&#39;.
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t))
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Return
     |      ------
     |      dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables, the intermediate
     |      scattering function (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and time t (in ``fs``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  t
     |      Get or set the times of the intermediate scattering function in units of
     |      ``fs``
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    PDF = class PairDistributionFunction(MDMC.trajectory_analysis.observables.obs.Observable)
     |  A class for containing, calculating and reading a pair distribution function (PDF).
     |
     |  We derive our definitions for this from the following publication:
     |  &#34;A comparison of various commonly used correlation functions for describing total scattering&#34;
     |  Keen, D. A. (2001). J. Appl. Cryst. 34, 172-177.
     |  DOI: https://doi.org/10.1107/S0021889800019993
     |
     |  We employ the following mathematical form for the total pair distribution function (``PDF``):
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |
     |      where :math:`c_i` is the number concentration of element :math:`i`,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`.
     |      (This corresponds to equation 8 in the above publication)
     |
     |
     |  The partial pair distribution, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |      (This corresponds to equation 10 in the above publication)
     |
     |  The total PDF is contained in ``PDF`` and the partial pair PDFs (if calculated or imported)
     |  are contained in ``partial_pdfs``.
     |
     |  Method resolution order:
     |      PairDistributionFunction
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the pair distribution function, :math:`G(r)`` from a
     |      ``CompactTrajectory``
     |
     |      The partial pair distribution for a pair i-j, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |
     |      This corresponds to the equation (8) in the following paper:
     |      &#34;A comparison of various commonly used correlation functions for
     |       describing total scattering&#34;
     |      Keen, D. A. (2001). J. Appl. Cryst. 34, 172-177.
     |      DOI: https://doi.org/10.1107/S0021889800019993
     |
     |      The total pair distribution function (``pdf.PDF``) has the form:
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |      where :math:`c_i` is the proportion of element :math:`i` in the material,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`
     |
     |      This corresponds to the equation (10) in the above paper.
     |
     |      Independent variables can either be set previously or defined within
     |      settings.
     |
     |      A number of frames can be specified, from which the ``PDF`` and its
     |      error are calculated. If the number of frames is too large relative to
     |      the run length, the samples will be correlated, which will result in an
     |      underestimate of the error.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |           A single ``CompactTrajectory`` object.
     |      verbose: int
     |          Verbose print settings. Not currently implemented for PDF.
     |      **settings
     |          n_frames : int
     |              The number of frames from which the pdf and its error are
     |              calculated. These frames are selected uniformly, and the step is taken to be
     |              n_frames / total number of frames rounded to the nearest positive integer.
     |              If this is not passed, 1% of the total number of frames are used
     |              (rounded up to the nearest positive integer).
     |          use_average : bool
     |              Optional parameter. If set to True then the mean value for PDF is
     |              calculated across selected frames from the trajectory. Also, the errors
     |              are set to the standard deviation calculated over the multiple frames.
     |              If set to False (default), only the last frame of the trajectory is used and
     |              n_frames will be ignored.
     |          subset : list of tuples
     |              The subset of element pairs from which the PDF is calculated.
     |              This can be used to calculate the partial PDFs of a
     |              multicomponent system. If this is not passed, all combinations
     |              of elements are used i.e. the PDF is the total PDF.
     |          b_coh : dict
     |              A dictionary containing coherent scattering length values for one or more elements.
     |              This can be used to calculate the PDF of a system where one or more elements
     |              has a coherent scattering length different from the coherent scattering length in
     |              MDMC.common.atom_properties (i.e. if it has been isotopically substituted).
     |          r_min : float
     |              The minimum ``r`` (atomic separation) in Angstrom for which the PDF will be
     |              calculated. If this, ``r_max``, and ``r_step`` are passed then
     |              these will create a range for the independent variable ``r``,
     |              which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r_max : float
     |              The maximum ``r`` (atomic separation) in Angstrom for which the PDF will be
     |              calculated. If this, ``r_min``, and ``r_step`` are passed then
     |              these will create a range for the independent variable ``r``,
     |              which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r_step : float
     |              The step size of ``r`` (atomic separation) for which the PDF
     |              will be calculated. If this, ``r_min``, and ``r_max`` are passed
     |              then these will create a range for the independent variable
     |              ``r``, which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r : numpy.ndarray
     |              The uniform ``r`` values in Angstrom for which the PDF will be calculated.
     |              This cannot be passed if ``r_min``, ``r_max``, and ``r_step``
     |              are passed.
     |          dimensions : array-like
     |              A 3 element `array-like` (`list`, `tuple`) with the dimensions
     |              of the ``Universe`` in Angstrom.
     |
     |
     |      Examples
     |      --------
     |      To calculate the O-O partial PDF from a simulation of water, use the
     |      subset keyword:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O)])
     |
     |      To calculate the sum of the H-O and O-O partial PDFs:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])
     |
     |      To calculate the total PDF for sodium chloride with 37Cl:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})
     |
     |      To calculate the total PDF for r values of [1., 2., 3., 4.]:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])
     |
     |      To calculate the total PDF over an average of 5 frames:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)
     |
     |  maximum_frames(self) -&gt; None
     |      There is no hard limit on the number of frames that can be used, so
     |      return None
     |
     |      Returns
     |      -------
     |      None
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to
     |      calculate the ``dependent_variables`` is 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`, not
     |          used
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  PDF
     |
     |  PDF_err
     |
     |  dependent_variables
     |      Get the dependent variables: these are PDF, the pair distribution function (in ``barn``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The shape of the &#39;PDF&#39; dependent variable in terms of &#39;r&#39;&#39;:
     |      np.shape(self.PDF)=(np.size(self.r))
     |
     |      Return
     |      ------
     |      dict
     |          The shape of the PDF dependent variable
     |
     |  uniformity_requirements
     |      Defines the current limitations on the atomic separation distance &#39;r&#39;
     |      of the ``PairDistributionFunction`` ``Observable.
     |      The requirement is that &#39;r&#39; must be uniform, but it does not have to start at zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;r&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the pair distribution function
     |      (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variable: this is
     |      the atomic separation distance r (in ``Ang``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  r
     |      Get or set the value of the atomic separation distance (in ``Ang``)
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;PairDistributionFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    class PairDistributionFunction(MDMC.trajectory_analysis.observables.obs.Observable)
     |  A class for containing, calculating and reading a pair distribution function (PDF).
     |
     |  We derive our definitions for this from the following publication:
     |  &#34;A comparison of various commonly used correlation functions for describing total scattering&#34;
     |  Keen, D. A. (2001). J. Appl. Cryst. 34, 172-177.
     |  DOI: https://doi.org/10.1107/S0021889800019993
     |
     |  We employ the following mathematical form for the total pair distribution function (``PDF``):
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |
     |      where :math:`c_i` is the number concentration of element :math:`i`,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`.
     |      (This corresponds to equation 8 in the above publication)
     |
     |
     |  The partial pair distribution, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |      (This corresponds to equation 10 in the above publication)
     |
     |  The total PDF is contained in ``PDF`` and the partial pair PDFs (if calculated or imported)
     |  are contained in ``partial_pdfs``.
     |
     |  Method resolution order:
     |      PairDistributionFunction
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the pair distribution function, :math:`G(r)`` from a
     |      ``CompactTrajectory``
     |
     |      The partial pair distribution for a pair i-j, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |
     |      This corresponds to the equation (8) in the following paper:
     |      &#34;A comparison of various commonly used correlation functions for
     |       describing total scattering&#34;
     |      Keen, D. A. (2001). J. Appl. Cryst. 34, 172-177.
     |      DOI: https://doi.org/10.1107/S0021889800019993
     |
     |      The total pair distribution function (``pdf.PDF``) has the form:
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |      where :math:`c_i` is the proportion of element :math:`i` in the material,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`
     |
     |      This corresponds to the equation (10) in the above paper.
     |
     |      Independent variables can either be set previously or defined within
     |      settings.
     |
     |      A number of frames can be specified, from which the ``PDF`` and its
     |      error are calculated. If the number of frames is too large relative to
     |      the run length, the samples will be correlated, which will result in an
     |      underestimate of the error.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |           A single ``CompactTrajectory`` object.
     |      verbose: int
     |          Verbose print settings. Not currently implemented for PDF.
     |      **settings
     |          n_frames : int
     |              The number of frames from which the pdf and its error are
     |              calculated. These frames are selected uniformly, and the step is taken to be
     |              n_frames / total number of frames rounded to the nearest positive integer.
     |              If this is not passed, 1% of the total number of frames are used
     |              (rounded up to the nearest positive integer).
     |          use_average : bool
     |              Optional parameter. If set to True then the mean value for PDF is
     |              calculated across selected frames from the trajectory. Also, the errors
     |              are set to the standard deviation calculated over the multiple frames.
     |              If set to False (default), only the last frame of the trajectory is used and
     |              n_frames will be ignored.
     |          subset : list of tuples
     |              The subset of element pairs from which the PDF is calculated.
     |              This can be used to calculate the partial PDFs of a
     |              multicomponent system. If this is not passed, all combinations
     |              of elements are used i.e. the PDF is the total PDF.
     |          b_coh : dict
     |              A dictionary containing coherent scattering length values for one or more elements.
     |              This can be used to calculate the PDF of a system where one or more elements
     |              has a coherent scattering length different from the coherent scattering length in
     |              MDMC.common.atom_properties (i.e. if it has been isotopically substituted).
     |          r_min : float
     |              The minimum ``r`` (atomic separation) in Angstrom for which the PDF will be
     |              calculated. If this, ``r_max``, and ``r_step`` are passed then
     |              these will create a range for the independent variable ``r``,
     |              which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r_max : float
     |              The maximum ``r`` (atomic separation) in Angstrom for which the PDF will be
     |              calculated. If this, ``r_min``, and ``r_step`` are passed then
     |              these will create a range for the independent variable ``r``,
     |              which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r_step : float
     |              The step size of ``r`` (atomic separation) for which the PDF
     |              will be calculated. If this, ``r_min``, and ``r_max`` are passed
     |              then these will create a range for the independent variable
     |              ``r``, which will overwrite any ``r`` which has previously been
     |              defined. This cannot be passed if ``r`` is passed.
     |          r : numpy.ndarray
     |              The uniform ``r`` values in Angstrom for which the PDF will be calculated.
     |              This cannot be passed if ``r_min``, ``r_max``, and ``r_step``
     |              are passed.
     |          dimensions : array-like
     |              A 3 element `array-like` (`list`, `tuple`) with the dimensions
     |              of the ``Universe`` in Angstrom.
     |
     |
     |      Examples
     |      --------
     |      To calculate the O-O partial PDF from a simulation of water, use the
     |      subset keyword:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O)])
     |
     |      To calculate the sum of the H-O and O-O partial PDFs:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])
     |
     |      To calculate the total PDF for sodium chloride with 37Cl:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})
     |
     |      To calculate the total PDF for r values of [1., 2., 3., 4.]:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])
     |
     |      To calculate the total PDF over an average of 5 frames:
     |
     |          .. highlight:: python
     |          .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)
     |
     |  maximum_frames(self) -&gt; None
     |      There is no hard limit on the number of frames that can be used, so
     |      return None
     |
     |      Returns
     |      -------
     |      None
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to
     |      calculate the ``dependent_variables`` is 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`, not
     |          used
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  PDF
     |
     |  PDF_err
     |
     |  dependent_variables
     |      Get the dependent variables: these are PDF, the pair distribution function (in ``barn``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The shape of the &#39;PDF&#39; dependent variable in terms of &#39;r&#39;&#39;:
     |      np.shape(self.PDF)=(np.size(self.r))
     |
     |      Return
     |      ------
     |      dict
     |          The shape of the PDF dependent variable
     |
     |  uniformity_requirements
     |      Defines the current limitations on the atomic separation distance &#39;r&#39;
     |      of the ``PairDistributionFunction`` ``Observable.
     |      The requirement is that &#39;r&#39; must be uniform, but it does not have to start at zero.
     |
     |      Return
     |      ------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;r&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the pair distribution function
     |      (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variable: this is
     |      the atomic separation distance r (in ``Ang``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  r
     |      Get or set the value of the atomic separation distance (in ``Ang``)
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;PairDistributionFunction&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    class SQw(AbstractSQw)
     |  A class for the total dynamic structure factor
     |
     |  Calculation is done in the respective FQt object, and this is
     |  just a reference to get the correct FQt object.
     |
     |  Method resolution order:
     |      SQw
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    SQwCoh = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    SQwIncoherentSQwIncoh = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_incoh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    SQw_coh = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_coh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

    SQw_incoh = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  name = &#39;SQw_incoh&#39;
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculates the time separation of frames required by the experimental
     |      dataset, assuming uniform spacing. Note that this may be different from
     |      the time separation that the user has given as an input, as it only
     |      depends on the current values for ``self.E``. The relationship between
     |      time and energy comes from the numpy implementation of the FFT for
     |      ``2 * nE`` points where:
     |
     |      .. math::
     |          \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the ``self.maximum_frames()``
     |      that can be used to recreate the grid of energy points, it can slice the
     |      ``CompactTrajectory`` into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``
     |      verbose: int, optional
     |          The level of verbosity:
     |          Verbose level 0 gives no information.
     |          Verbose level 1 gives final time for the whole method.
     |          Verbose level 2 gives final time and also a progress bar.
     |          Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          ``n_Q_vectors`` (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          ``dimensions`` (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |          ``energy_resolution` (`dict`)
     |              Optionally specify energy resolution and function in units of ueV (micro eV),
     |              in the format of the one-line dict {&#39;function&#39;: value}, where `function`
     |              is the resolution function and `value` is the desired `FWHM`.
     |              e.g. to pass a Gaussian resolution of 80ueV we use {&#39;gaussian&#39;: 80}.
     |              Currently accepted functions are &#39;gaussian&#39; and &#39;lorentzian&#39;
     |              Can also be &#39;lazily&#39; given as `float`, in which case it is assumed to be Gaussian.
     |          ``Q_values`` (`array`)
     |              1D array of Q `float` (in ``Ang^-1``). (optional)
     |          ``use_average`` (`bool`)
     |              Optional parameter if a list of more than one ``Trajectory`` is used. If set to
     |              True (default) then the mean value for S(Q, w) is calculated. Also, the errors
     |              are set to the standard deviation calculated over the list of
     |              ``CompactTrajectory`` objects.
     |           ``cont_slicing`` (`bool`)
     |              Flag to decide between two possible behaviours when the number of ``MD_steps`` is
     |              larger than the minimum required to calculate the observables. If ``False``
     |              (default) then the ``CompactTrajectory`` is sliced into non-overlapping
     |              sub-``CompactTrajectory`` blocks for each of which the observable is calculated.
     |              If ``True``, then the ``CompactTrajectory`` is sliced into as many non-identical
     |              sub-``CompactTrajectory`` blocks as possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generates a resolution function in momentum and time that can be used in the calculation of
     |      SQw. Note that this uses the ``SQw`` values of the ``Observable`` it is called from, and so
     |      should only be called for an observable which has been created from relevant resolution
     |      data, i.e. a vanadium sample.
     |
     |      Note that if this resolution function is used on data outside its original range, then it
     |      will use nearest neighbour extrapolation. Additionally, the input will be reflected in the
     |      time/energy domain as symmetry about 0 is assumed. If for whatever reason this is not
     |      appropriate for the data in question, this function should not be used.
     |
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing to use when performing the inverse Fourier transform in units of `fs`.
     |          Ideally this should be the same as the frame separation expected when applying this
     |          function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function which accepts arrays of time
     |          and momentum (respectively) and returns a 2D array of values for the instrument
     |          resolution.
     |
     |  validate_energy(self, dt: float) -&gt; None
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      includes the time separation required in the error.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          Frame separation in ``fs``
     |
     |      Returns
     |      -------
     |      None
     |
     |      Raises
     |      ------
     |      AssertionError
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Calculates an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``. The
     |      frequencie are determined by the Fast Fourier Transform, as implemented
     |      by numpy, for ``2 * nE`` points in time which we then crop to only
     |      include ``nE`` positive frequencies. As we are dealing with frequency
     |      rather than angular frequency here, the relation to between energy
     |      is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated
     |      dt : float
     |          The step size between frames in ``fs``
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables: this is SQw, the
     |      dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E))
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Return
     |      ------
     |      Dict[str, list]
     |          The shape of the SQw dependent variable
     |
     |  uniformity_requirements
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Return
     |      ------
     |      Dict[str, Dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables, the dynamic
     |      structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``
     |
     |  independent_variables
     |      Get or set the independent variables: these are
     |      the frequency Q (in ``Ang^-1``) and energy E (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      The maximum number of ``CompactTrajectory`` frames that can be used to
     |      calculate the ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of ``CompactTrajectory`` frames needed to calculate the
     |      ``dependent_variables`` depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables (if defined)
     |
     |  __weakref__
     |      list of weak references to the object (if defined)
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self)
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Reads in experimental data from a file using a specified reader
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader
     |      file_name : str
     |          The name of the file
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  origin
     |      Get or set the origin of the observable
     |
     |      Returns
     |      -------
     |      str
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT

DATA
    __all__ = [&#39;CoherentDynamicStructureFactor&#39;, &#39;CoherentIntermediateScat...

FILE
    /usr/local/lib/python3.11/site-packages/MDMC/trajectory_analysis/observables/__init__.py


</pre></div></div>
</div>
<p>As is mentioned in the Examples section, each observable may have one or more aliases. So both <code class="docutils literal notranslate"><span class="pre">DynamicStructureFactor</span></code> or <code class="docutils literal notranslate"><span class="pre">SQw</span></code> can be used for calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span>.</p>
<p>Some of the details given below are specific to calculating the dynamic structure factor, however the general method can be followed for any observable.</p>
<p>Argon has comparable scattering lengths for both coherent and incoherent scattering, so the total scattering has clear contributions from each. For the purposes of this tutorial we will simply calculate <span class="math notranslate nohighlight">\(S(Q,\omega)_{coh}\)</span> and compare it with experimental data; the exercise of calculating the incoherent and total scattering is left as an exercise for the reader.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span> <span class="o">=</span> <span class="n">observables</span><span class="o">.</span><span class="n">SQwCoh</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The dynamic structure factor has two independent variables, the scattering wavevector, <span class="math notranslate nohighlight">\(Q\)</span>, and <span class="math notranslate nohighlight">\(E\)</span> (or <span class="math notranslate nohighlight">\(\hbar\omega\)</span>) is the energy transfer.</p>
<p>The size of the simulation box defines the spacing (and therefore the lower bound) of <span class="math notranslate nohighlight">\(Q\)</span> values; however any Q values can be specified for calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span> and MDMC will simply calculate it for valid values.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using the arange function from NumPy - this creates an uniform array of floats with a</span>
<span class="c1"># start (0.42), stop (3.8) and step (0.3) specified below</span>
<span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.42</span><span class="p">,</span> <span class="mf">3.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q will be calculated for values of: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Q will be calculated for values of: [0.42 0.72 1.02 1.32 1.62 1.92 2.22 2.52 2.82 3.12 3.42 3.72]
</pre></div></div>
</div>
<p>The total duration of the trajectory defines the smallest spacing of the <span class="math notranslate nohighlight">\(E\)</span> values. If <span class="math notranslate nohighlight">\(E\)</span> values are not specified, MDMC will simply calculate the <span class="math notranslate nohighlight">\(E\)</span> values with this spacing. However for this setting there will only be two points in the trajectory contributing to each energy bin and the statistics will be poor (<strong>should take ~30s to execute</strong>):</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the Q values for the Q independent variable</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">independent_variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">}</span>

<span class="c1"># Calculate the coherent dynamic structure factor</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>

<span class="c1"># Use the plotting function defined above to plot the result</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='37c85760-5bc6-4d79-8c2d-ddd598d342df'></div></div>
</div>
<p>Therefore it is strongly recommended that you specify the <span class="math notranslate nohighlight">\(E\)</span> values for calculating the dynamic structure factor.</p>
<p>The allowed values of <span class="math notranslate nohighlight">\(E\)</span> (in meV) are determined by trajectory times. To aid in calculating these, the <code class="docutils literal notranslate"><span class="pre">calulate_E</span></code> method can be used, which requires the time step of the trajectory (in fs) and the total number of E values to be calculated. The number of E values should be changed to improve the statistics, but somewhere in the range of 1/4 to 1/8 of the total number of trajectory configurations (i.e. the number of times for which a configuration was recorded) will be probably
reasonable:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This subtracts the time of the zeroeth step from the time of the first step</span>
<span class="c1"># It should be equal to the time_step * traj_step passed to Simulation</span>
<span class="n">trajectory_timestep</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CompactTrajectory time step: </span><span class="si">{}</span><span class="s1"> fs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trajectory_timestep</span><span class="p">))</span>

<span class="n">n_configurations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of trajectory configurations: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_configurations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
CompactTrajectory time step: 250.0 fs
Number of trajectory configurations: 481
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_E</span><span class="p">((</span><span class="n">n_configurations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">trajectory_timestep</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculated E values are: </span><span class="se">\n</span><span class="si">{}</span><span class="s1"> meV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Calculated E values are:
[0.         0.10339169 0.20678338 0.31017508 0.41356677 0.51695846
 0.62035015 0.72374185 0.82713354 0.93052523 1.03391692 1.13730862
 1.24070031 1.344092   1.44748369 1.55087539 1.65426708 1.75765877
 1.86105046 1.96444216 2.06783385 2.17122554 2.27461723 2.37800893
 2.48140062 2.58479231 2.688184   2.79157569 2.89496739 2.99835908
 3.10175077 3.20514246 3.30853416 3.41192585 3.51531754 3.61870923
 3.72210093 3.82549262 3.92888431 4.032276   4.1356677  4.23905939
 4.34245108 4.44584277 4.54923447 4.65262616 4.75601785 4.85940954
 4.96280124 5.06619293 5.16958462 5.27297631 5.376368   5.4797597
 5.58315139 5.68654308 5.78993477 5.89332647 5.99671816 6.10010985
 6.20350154 6.30689324 6.41028493 6.51367662 6.61706831 6.72046001
 6.8238517  6.92724339 7.03063508 7.13402678 7.23741847 7.34081016
 7.44420185 7.54759355 7.65098524 7.75437693 7.85776862 7.96116031
 8.06455201 8.1679437 ] meV
</pre></div></div>
</div>
<p>Of course if the <span class="math notranslate nohighlight">\(E\)</span> resolution required is lower (i.e. step between the <code class="docutils literal notranslate"><span class="pre">E</span></code> values can be larger), the number of E values specified can be reduced:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A reduced E resolution: </span><span class="se">\n</span><span class="si">{}</span><span class="s1"> meV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_E</span><span class="p">((</span><span class="n">n_configurations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">24</span><span class="p">,</span> <span class="n">trajectory_timestep</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
A reduced E resolution:
[0.         0.41356677 0.82713354 1.24070031 1.65426708 2.06783385
 2.48140062 2.89496739 3.30853416 3.72210093 4.1356677  4.54923447
 4.96280124 5.376368   5.78993477 6.20350154 6.61706831 7.03063508
 7.44420185 7.85776862] meV
</pre></div></div>
</div>
<p>Now we can use <code class="docutils literal notranslate"><span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">E</span></code> to set the indepedendent variables of <code class="docutils literal notranslate"><span class="pre">sqw_coh</span></code>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">independent_variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="n">E</span><span class="p">,</span>
                                 <span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Using this binning, recalculate the dynamic structure factor, which is smoother due to better statistics <strong>This calculation should take ~30s.</strong>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='c5536683-440f-4ede-9d88-3da1b4370448'></div></div>
</div>
<p>We can compare this with experimental data measured using quasi-elastic neutron scattering (QENS) data (specifically here the van Well et al. Phys. Rev. A <strong>31</strong> 3391 (1985) data, which the authors corrected for instrument resolution) by reading the data into an SQwCoh object:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a second SQwCoh object, this time called sqw_exp</span>
<span class="n">sqw_exp</span> <span class="o">=</span> <span class="n">observables</span><span class="o">.</span><span class="n">SQwCoh</span><span class="p">()</span>

<span class="c1"># Read the data from the file ./data/Well_s_q_omega_Ar_data.xml using the `xml_SQw` reader</span>
<span class="n">sqw_exp</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="s1">&#39;xml_SQw&#39;</span><span class="p">,</span> <span class="s1">&#39;./data/Well_s_q_omega_Ar_data.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The independent and dependent variables are read into the same attributes (<code class="docutils literal notranslate"><span class="pre">sqw_coh.E</span></code>, <code class="docutils literal notranslate"><span class="pre">sqw_exp.Q</span></code>, and <code class="docutils literal notranslate"><span class="pre">sqw_exp.SQw</span></code>) as if they had been calculated from MD (as in <code class="docutils literal notranslate"><span class="pre">sqw_coh</span></code> above).</p>
<p>For many QENS datasets (if not most) the instrument resolution has not been removed, and to compare with MD simulation this requires the simulation output to be convolution with the instrument resolution. One way this can be done is using: the optional <code class="docutils literal notranslate"><span class="pre">energy_resolution</span></code>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># energy_resolution is the FWHM of the instrumentation&#39;s resolution function expressed in ueV (micro eV).</span>
<span class="c1"># It is used to smooth the calculated S(Q,w) with a Gaussian window in order to match the values obtained experimentally.</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">energy_resolution</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="mf">1.0e3</span><span class="p">})</span>

<span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (fig.ws.readyState == 1 && width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '" + msg_type + "' message type: ",
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '" + msg_type + "' message: ", msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_" + msg_type + "' callback:",
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='d6da6453-5dd4-4187-9279-adae86cb39dd'></div></div>
</div>
</section>
<section id="Other-observables">
<h2>Other observables<a class="headerlink" href="#Other-observables" title="Permalink to this headline"></a></h2>
<p>The same applies for the observables, such as the pair distribution function <span class="math notranslate nohighlight">\(G(r)\)</span>. To determine how to calculate another observables from an MD trajectory, please see the associated help documentation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">observables</span><span class="o">.</span><span class="n">PDF</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on function calculate_from_MD in module MDMC.trajectory_analysis.observables.pdf:

calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
    Calculate the pair distribution function, :math:`G(r)`` from a
    ``CompactTrajectory``

    The partial pair distribution for a pair i-j, :math:`g_{ij}`, is:

    .. math::

        g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}

    where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
    atoms around atoms of element :math:`i`, with bins of size
    :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
    atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
    :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.

    This corresponds to the equation (8) in the following paper:
    &#34;A comparison of various commonly used correlation functions for
     describing total scattering&#34;
    Keen, D. A. (2001). J. Appl. Cryst. 34, 172-177.
    DOI: https://doi.org/10.1107/S0021889800019993

    The total pair distribution function (``pdf.PDF``) has the form:

    .. math::

        G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)

    where :math:`c_i` is the proportion of element :math:`i` in the material,
    :math:`b_i` is the (coherent) scattering length of element :math:`i`

    This corresponds to the equation (10) in the above paper.

    Independent variables can either be set previously or defined within
    settings.

    A number of frames can be specified, from which the ``PDF`` and its
    error are calculated. If the number of frames is too large relative to
    the run length, the samples will be correlated, which will result in an
    underestimate of the error.

    Parameters
    ----------
    MD_input : CompactTrajectory
         A single ``CompactTrajectory`` object.
    verbose: int
        Verbose print settings. Not currently implemented for PDF.
    **settings
        n_frames : int
            The number of frames from which the pdf and its error are
            calculated. These frames are selected uniformly, and the step is taken to be
            n_frames / total number of frames rounded to the nearest positive integer.
            If this is not passed, 1% of the total number of frames are used
            (rounded up to the nearest positive integer).
        use_average : bool
            Optional parameter. If set to True then the mean value for PDF is
            calculated across selected frames from the trajectory. Also, the errors
            are set to the standard deviation calculated over the multiple frames.
            If set to False (default), only the last frame of the trajectory is used and
            n_frames will be ignored.
        subset : list of tuples
            The subset of element pairs from which the PDF is calculated.
            This can be used to calculate the partial PDFs of a
            multicomponent system. If this is not passed, all combinations
            of elements are used i.e. the PDF is the total PDF.
        b_coh : dict
            A dictionary containing coherent scattering length values for one or more elements.
            This can be used to calculate the PDF of a system where one or more elements
            has a coherent scattering length different from the coherent scattering length in
            MDMC.common.atom_properties (i.e. if it has been isotopically substituted).
        r_min : float
            The minimum ``r`` (atomic separation) in Angstrom for which the PDF will be
            calculated. If this, ``r_max``, and ``r_step`` are passed then
            these will create a range for the independent variable ``r``,
            which will overwrite any ``r`` which has previously been
            defined. This cannot be passed if ``r`` is passed.
        r_max : float
            The maximum ``r`` (atomic separation) in Angstrom for which the PDF will be
            calculated. If this, ``r_min``, and ``r_step`` are passed then
            these will create a range for the independent variable ``r``,
            which will overwrite any ``r`` which has previously been
            defined. This cannot be passed if ``r`` is passed.
        r_step : float
            The step size of ``r`` (atomic separation) for which the PDF
            will be calculated. If this, ``r_min``, and ``r_max`` are passed
            then these will create a range for the independent variable
            ``r``, which will overwrite any ``r`` which has previously been
            defined. This cannot be passed if ``r`` is passed.
        r : numpy.ndarray
            The uniform ``r`` values in Angstrom for which the PDF will be calculated.
            This cannot be passed if ``r_min``, ``r_max``, and ``r_step``
            are passed.
        dimensions : array-like
            A 3 element `array-like` (`list`, `tuple`) with the dimensions
            of the ``Universe`` in Angstrom.


    Examples
    --------
    To calculate the O-O partial PDF from a simulation of water, use the
    subset keyword:

        .. highlight:: python
        .. code-block:: python

        pdf.calculate_from_MD(trajectory, subset=[(O, O)])

    To calculate the sum of the H-O and O-O partial PDFs:

        .. highlight:: python
        .. code-block:: python

        pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])

    To calculate the total PDF for sodium chloride with 37Cl:

        .. highlight:: python
        .. code-block:: python

        pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})

    To calculate the total PDF for r values of [1., 2., 3., 4.]:

        .. highlight:: python
        .. code-block:: python

        pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])

    To calculate the total PDF over an average of 5 frames:

        .. highlight:: python
        .. code-block:: python

        pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)

</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="running-a-simulation.html" class="btn btn-neutral float-left" title="Running a Simulation in MDMC" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="selecting-fitting-parameters.html" class="btn btn-neutral float-right" title="Selecting Fitting Parameters" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>