

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Creating an Observable from a Simulation &mdash; MDMC 0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/nbsphinx-code-cells.css?v=2aa19091" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=10f1778b"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Parameter Refinement" href="../parameter-refinement.html" />
    <link rel="prev" title="Running a Simulation in MDMC" href="running-a-simulation.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MDMC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing.html">2. Contributing to MDMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/Argon-a-to-z.html">Argon A-to-Z</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/accessing-atom-properties.html">Creating Atoms and Accessing Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/equilibrating-a-simulation.html">Equilibrating simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/running-a-refinement.html">Running a Refinement (in detail)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/understanding-units.html">Understanding scientific units in MDMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How-to</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../use-MDMC.html">How to use MDMC</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../simulations.html">Simulations</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../simulations.html#creating-a-universe">Creating a Universe</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../simulations.html#creating-a-simulation">Creating a Simulation</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="running-a-simulation.html">Running a Simulation in MDMC</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">Creating an Observable from a Simulation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="creating-atomic-configurations.html">Creating an atomic configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="defining-molecule-interactions.html">Defining molecule interactions</a></li>
<li class="toctree-l2"><a class="reference internal" href="solvating-a-universe.html">Solvating an MDMC Universe</a></li>
<li class="toctree-l2"><a class="reference internal" href="read-configurations.html">Reading atoms from configuration files</a></li>
<li class="toctree-l2"><a class="reference internal" href="molecular-visualization.html">Visualising a Universe</a></li>
<li class="toctree-l2"><a class="reference internal" href="applying-a-forcefield.html">Applying a force field</a></li>
<li class="toctree-l2"><a class="reference internal" href="../parameter-refinement.html">Parameter Refinement</a></li>
<li class="toctree-l2"><a class="reference internal" href="selecting-fitting-parameters.html">Selecting which parameters to fit</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials/running-a-refinement.html">Running a Refinement (in detail)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/api/modules.html">MDMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Explanation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../explanation/explanation.html">Explanation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../developer/overview.html">Developer Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MDMC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../use-MDMC.html">How to use MDMC</a></li>
          <li class="breadcrumb-item"><a href="../simulations.html">Simulations</a></li>
      <li class="breadcrumb-item active">Creating an Observable from a Simulation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/how-to/use-MDMC/notebooks/creating-an-observable.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Creating-an-Observable-from-a-Simulation">
<h1>Creating an Observable from a Simulation<a class="headerlink" href="#Creating-an-Observable-from-a-Simulation" title="Link to this heading"></a></h1>
<p>To run a refinement, MDMC makes quantitative comparisons between a dynamical property derived from an experiment, and the equivalent dynamical property calculated from our MD simulation. Within MDMC each of these properties is called an <code class="docutils literal notranslate"><span class="pre">Observable</span></code>. Examples of these observables are the <a class="reference external" href="https://en.wikipedia.org/wiki/Dynamic_structure_factor">dynamic structure factor</a>, <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span>, and the <a class="reference external" href="https://en.wikipedia.org/wiki/Pair_distribution_function">pair distribution function</a>,
<span class="math notranslate nohighlight">\(G(r)\)</span>.</p>
<p>Within a refinement, each <code class="docutils literal notranslate"><span class="pre">Observable</span></code> is calculated from MD automatically. However it is also useful to be able to calculate an <code class="docutils literal notranslate"><span class="pre">Observable</span></code> from an MD simulation and plot it, which is demonstrated in this tutorial.</p>
<p>This tutorial requires matplotlib, the Python plotting library, to be installed; if it is not installed, install it in the terminal with the command <code class="docutils literal notranslate"><span class="pre">pip3</span> <span class="pre">install</span> <span class="pre">matplotlib</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="o">%</span><span class="k">matplotlib</span> notebook
    <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">mpl_toolkits.mplot3d</span><span class="w"> </span><span class="kn">import</span> <span class="n">Axes3D</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please install matplotlib and restart the kernel!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<section id="Running-a-simulation">
<h2>Running a simulation<a class="headerlink" href="#Running-a-simulation" title="Link to this heading"></a></h2>
<p>Below we setup and run a simulation of liquid argon so that we have a <code class="docutils literal notranslate"><span class="pre">CompactTrajectory</span></code> from which to calculate an <code class="docutils literal notranslate"><span class="pre">Observable</span></code>.</p>
<p>If the building of the universe and simulation is confusing to you, please see the guides for how to <a class="reference internal" href="creating-atomic-configurations.html"><span class="doc">create atomic configurations</span></a>, <a class="reference internal" href="defining-molecule-interactions.html"><span class="doc">define molecule interactions</span></a> and <a class="reference internal" href="running-a-simulation.html"><span class="doc">run a simulation</span></a> - or the <a class="reference internal" href="../../../tutorials/Argon-a-to-z.html"><span class="doc">Argon a-to-z</span></a> tutorial.</p>
<p><strong>As this is minimizing, equilibrating, and running a simulation, this should take ~3 minutes to execute</strong>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">MDMC.MD</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Build universe</span>
<span class="n">universe</span> <span class="o">=</span> <span class="n">Universe</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="mf">38.4441</span><span class="p">)</span>
<span class="n">Ar</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;Ar&#39;</span><span class="p">,</span> <span class="n">charge</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
<span class="c1"># Fill box with 1000 atoms, and hence atoms per AA^-3 density = 0.0176</span>
<span class="n">universe</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">Ar</span><span class="p">,</span> <span class="n">num_struc_units</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Universe contains </span><span class="si">{}</span><span class="s1"> Ar atoms&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">universe</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
<span class="n">Ar_dispersion</span> <span class="o">=</span> <span class="n">Dispersion</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span>
                           <span class="p">(</span><span class="n">Ar</span><span class="o">.</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">Ar</span><span class="o">.</span><span class="n">atom_type</span><span class="p">),</span>
                           <span class="n">cutoff</span><span class="o">=</span><span class="mf">8.</span><span class="p">,</span>
                           <span class="n">vdw_tail_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">function</span><span class="o">=</span><span class="n">LennardJones</span><span class="p">(</span><span class="mf">1.0243</span><span class="p">,</span> <span class="mf">3.36</span><span class="p">))</span>

<span class="c1"># MD Engine setup</span>
<span class="n">simulation</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span><span class="n">universe</span><span class="p">,</span>
                        <span class="n">engine</span><span class="o">=</span><span class="s2">&quot;lammps&quot;</span><span class="p">,</span>
                        <span class="n">time_step</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                        <span class="n">temperature</span><span class="o">=</span><span class="mf">120.</span><span class="p">,</span>
                        <span class="n">traj_step</span><span class="o">=</span><span class="mi">25</span><span class="p">)</span>

<span class="n">simulation</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>  <span class="c1"># energy minimisation</span>
<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">n_steps</span><span class="o">=</span><span class="mi">20000</span><span class="p">,</span> <span class="n">equilibration</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># equilibration</span>

<span class="n">simulation</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="mi">12025</span><span class="p">)</span>  <span class="c1"># the actual run!</span>
<span class="n">trajectory</span> <span class="o">=</span> <span class="n">simulation</span><span class="o">.</span><span class="n">trajectory</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Universe created with:
Dimensions [38.44 38.44 38.44]
Universe contains 1000 Ar atoms
LAMMPS output is captured by PyLammps wrapperLAMMPS (2 Aug 2023 - Update 4)
OMP_NUM_THREADS environment is not set. Defaulting to 1 thread. (src/comm.cpp:98)
  using 1 OpenMP thread(s) per MPI task

LAMMPS (2 Aug 2023 - Update 4)
OMP_NUM_THREADS environment is not set. Defaulting to 1 thread. (src/comm.cpp:98)
  using 1 OpenMP thread(s) per MPI task
LAMMPS output is captured by PyLammps wrapper
Total wall time: 0:00:00
Simulation created with lammps engine and settings:
temperature: 120.0 K


</pre></div></div>
</div>
<p>Before our excursion into calculating the dynamic structure factor from this trajectory, we define a helper function <code class="docutils literal notranslate"><span class="pre">plot_surface</span></code> which will let us easily visualise our observable as a 3D plot.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_surface</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">surf</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</section>
<section id="Calculating-S(Q,\omega)">
<h2>Calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span><a class="headerlink" href="#Calculating-S(Q,\omega)" title="Link to this heading"></a></h2>
<p>To see which observables can be calculated, use the <code class="docutils literal notranslate"><span class="pre">help</span></code> function to look at the observables module documentation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">MDMC.trajectory_analysis</span><span class="w"> </span><span class="kn">import</span> <span class="n">observables</span>
<span class="n">help</span><span class="p">(</span><span class="n">observables</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on package MDMC.trajectory_analysis.observables in MDMC.trajectory_analysis:

NAME
    MDMC.trajectory_analysis.observables - Modules calculating observables from molecular dynamics trajectories.

DESCRIPTION
    Observables
    -----------
    DynamicStructureFactor / SQw
    CoherentDynamicStructureFactor / SQwCoherent / SQwCoh / SQw_coh
    IncoherentDynamicStructureFactor / SQwIncoherentSQwIncoh / SQw_incoh
    IntermediateScatteringFunction / FQt
    IncoherentIntermediateScatteringFunction / FQtIncoherentFQtIncoh / FQt_incoh
    PDF / PairDistributionFunction
    CoherentIntermediateScatteringFunction / FQtCoherent / FQtCoh / FQt_coh

    Examples
    --------
    Observables can be instantiated using the names above.

    For instance an SQw observable can be instantiated using either of the aliases:

    .. code-block:: python

        from MDMC.trajectory_analysis import observables
        sqw = observables.SQw()                     # This line...
        sqw = observables.DynamicStructureFactor()  # ...is equivalent to this line

PACKAGE CONTENTS
    concurrency_tools
    fqt
    fqt_coh
    fqt_incoh
    obs
    obs_factory
    pdf
    sqw

CLASSES
    MDMC.trajectory_analysis.observables.fqt.AbstractFQt(MDMC.trajectory_analysis.observables.sqw.SQwMixins, MDMC.trajectory_analysis.observables.obs.Observable)
        MDMC.trajectory_analysis.observables.fqt.FQt
        MDMC.trajectory_analysis.observables.fqt_coh.FQtCoherent
        MDMC.trajectory_analysis.observables.fqt_incoh.FQtIncoherent
    MDMC.trajectory_analysis.observables.obs.Observable(abc.ABC)
        MDMC.trajectory_analysis.observables.pdf.PairDistributionFunction
    MDMC.trajectory_analysis.observables.sqw.AbstractSQw(MDMC.trajectory_analysis.observables.sqw.SQwMixins, MDMC.trajectory_analysis.observables.obs.Observable)
        MDMC.trajectory_analysis.observables.sqw.SQw
        MDMC.trajectory_analysis.observables.sqw.SQwCoherent
        MDMC.trajectory_analysis.observables.sqw.SQwIncoherent

    CoherentDynamicStructureFactor = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    CoherentIntermediateScatteringFunction = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing the intermediate scattering function for coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    DynamicStructureFactor = class SQw(AbstractSQw)
     |  A class for the total dynamic structure factor.
     |
     |  Calculation is done in the respective FQt object, and this is
     |  just a reference to get the correct FQt object.
     |
     |  Method resolution order:
     |      SQw
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    class FQt(AbstractFQt)
     |  Class to process the intermediate scattering function for the total dynamic structure factor.
     |
     |  Method resolution order:
     |      FQt
     |      AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    FQtCoh = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing the intermediate scattering function for coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing the intermediate scattering function for coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    FQtIncoherentFQtIncoh = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing intermediate scattering function for incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    FQt_coh = class FQtCoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing the intermediate scattering function for coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtCoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    FQt_incoh = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing intermediate scattering function for incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    IncoherentDynamicStructureFactor = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    IncoherentIntermediateScatteringFunction = class FQtIncoherent(MDMC.trajectory_analysis.observables.fqt.AbstractFQt)
     |  Class for processing intermediate scattering function for incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      FQtIncoherent
     |      MDMC.trajectory_analysis.observables.fqt.AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.fqt.AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    IntermediateScatteringFunction = class FQt(AbstractFQt)
     |  Class to process the intermediate scattering function for the total dynamic structure factor.
     |
     |  Method resolution order:
     |      FQt
     |      AbstractFQt
     |      MDMC.trajectory_analysis.observables.sqw.SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractFQt:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  apply_resolution(self, resolution: MDMC.resolution.resolution.Resolution) -&gt; &#39;FQt&#39;
     |      Apply instrument resolution to an FQt object.
     |
     |      Parameters
     |      ----------
     |      resolution : Resolution
     |          The Resolution object to apply to FQt.
     |
     |      Returns
     |      -------
     |      FQt
     |          The FQt object with resolution applied.
     |
     |  calculate_SQw(self, energy: list[float], resolution: MDMC.resolution.resolution.Resolution = None) -&gt; numpy.ndarray
     |      Calculate S(Q, w) from F(Q, t), accounting for instrument resolution.
     |
     |      In order to obtain ``len(energy)`` values in energy, we reflect the
     |      intermediate scattering function in time to give it dimensions of
     |      ``(len(self.Q), 2 * (len(self.t)) - 2)``. This uses the fact it is even
     |      in time, and the number of time points is chosen to be 1 greater than
     |      the number of energy points [Rapaport, The Art of Molecular Dynamics
     |      Simulation (2nd Edition), 2004, page 142].
     |
     |      The numpy implementation of the FFT gives frequencies arranged so that
     |      the first ``len(energy)`` points in the energy dimension correspond to
     |      positive frequencies, and the remaining points have negative frequency.
     |
     |      Parameters
     |      ----------
     |      energy : list of floats
     |          The list of energy (E) points at which S(Q, w) will be calculated.
     |      resolution : Resolution (default None)
     |          The instrument resolution object which will be applied to FQt.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          The S(Q, w) calculated from F(Q, t).
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict) -&gt; None
     |      Calculate the intermediate scattering function from a trajectory.
     |
     |      ``independent_variables`` can either be set previously or defined within
     |      ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          ``CompactTrajectory`` object to compute F(Q, t) from.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings
     |          **n_Q_vectors** (`int`)
     |              The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |              greater the number of ``Q_vectors``, the more accurate the
     |              calculation, but the longer it will take.
     |          **dimensions** (`list`, `tuple`, `numpy.ndarray`)
     |              A 3 element `tuple` or ``array`` of `float` specifying the
     |              dimensions of the ``Universe`` in units of ``Ang``
     |
     |  calculate_rho_config(self, config: numpy.ndarray, single_Q_vectors: list) -&gt; numpy.ndarray
     |      Calculate density over an entire configuration.
     |
     |      Parameters
     |      ----------
     |      config : np.ndarray
     |          An array of atom positions.
     |      single_Q_vectors : list
     |          A list of Q-vectors for a single value of Q.
     |
     |      Returns
     |      -------
     |      np.ndarray
     |          An array of rho values for each timestep summed over the
     |          atoms in the system, corresponding to each Q.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractFQt:
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is FQt, the intermediate scattering function (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order of indexing of &#39;FQt&#39; dependent variables in terms of &#39;Q&#39; and &#39;t&#39;.
     |
     |      The purpose of this method is to ensure consistency between
     |      different readers/methods which create ``FQt`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.FQt[Q_index, t_index] is the data point
     |      for given indices of self.Q and self.t.
     |
     |      It also means that:
     |      np.shape(self.FQt)=(np.size(self.Q), np.size(self.t)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Capture the current limitations on the time &#39;t&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the intermediate scattering function ``Observables``.
     |
     |      If using FFT, then &#39;t&#39; must be uniform and start at zero,
     |      otherwise it has no restrictions. &#39;Q&#39; must be uniform but does
     |      not need to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;t&#39; and &#39;Q&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractFQt:
     |
     |  FQt
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the intermediate scattering function error (in ``arb``).
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are the frequency Q (in ``Ang^-1``) and time t (in ``fs``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  t
     |      Get or set the times of the intermediate scattering function (in ``fs``).
     |
     |      Returns
     |      -------
     |      numpy.array
     |          1D array of times in ``fs``.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.sqw.SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    PDF = class PairDistributionFunction(MDMC.trajectory_analysis.observables.obs.Observable)
     |  Class for processing a pair distribution function (PDF).
     |
     |  We derive our definitions for this from [Keen]_:
     |
     |  We employ the following mathematical form for the total pair
     |  distribution function (``PDF``):
     |
     |  .. math::
     |
     |      G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |  where :math:`c_i` is the number concentration of element :math:`i`,
     |  :math:`b_i` is the (coherent) scattering length of element :math:`i`.
     |  (This corresponds to equation 8 in the above publication)
     |
     |  The partial pair distribution, :math:`g_{ij}`, is:
     |
     |  .. math::
     |
     |      g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |  where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |  atoms around atoms of element :math:`i`, with bins of size
     |  :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |  atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |  :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |  (This corresponds to equation 10 in the above publication)
     |
     |  The total PDF is contained in ``PDF`` and the partial pair PDFs
     |  (if calculated or imported) are contained in ``partial_pdfs``.
     |
     |  References
     |  ----------
     |  .. [Keen] Keen, D. A.,
     |     &#34;A comparison of various commonly used correlation functions for describing total scattering&#34;
     |     J. Appl. Cryst. 34 (2001) 172-177.
     |
     |     DOI: https://doi.org/10.1107/S0021889800019993
     |
     |  Method resolution order:
     |      PairDistributionFunction
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the pair distribution function, :math:`G(r)` from a ``CompactTrajectory``.
     |
     |      The partial pair distribution (from __) for a pair i-j, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum\limits_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |
     |      The total pair distribution function (``pdf.PDF``) has the form:
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |      where :math:`c_i` is the proportion of element :math:`i` in the material,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`
     |
     |      This corresponds to the equation (10) in the above paper.
     |
     |      Independent variables can either be set previously or defined within
     |      settings.
     |
     |      A number of frames can be specified, from which the ``PDF`` and its
     |      error are calculated. If the number of frames is too large relative to
     |      the run length, the samples will be correlated, which will result in an
     |      underestimate of the error.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          A single ``CompactTrajectory`` object.
     |      verbose : int
     |          Verbose print settings. Not currently implemented for PDF.
     |      **settings
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_frames : int
     |          The number of frames from which the PDF and its error are
     |          calculated. These frames are selected uniformly, and the
     |          step is taken to be n_frames / total number of frames
     |          rounded to the nearest positive integer.
     |
     |          If this is not passed, 1% of the total number of frames
     |          are used (rounded up).
     |      use_average : bool
     |          If set to `False` (default), only the last frame of the
     |          trajectory is used and n_frames will be ignored.
     |
     |          If set to `True` then the mean value for PDF is calculated
     |          across selected frames from the trajectory. Also, the
     |          errors are set to the standard deviation calculated over
     |          the multiple frames.
     |      subset : list of tuples
     |          The subset of element pairs from which the PDF is calculated.
     |
     |          This can be used to calculate the partial PDFs of a
     |          multicomponent system. If this is not passed, all combinations
     |          of elements are used i.e. the PDF is the total PDF.
     |      b_coh : dict
     |          A dictionary containing coherent scattering length values
     |          for one or more elements.
     |
     |          This can be used to calculate
     |          the PDF of a system where one or more elements has a
     |          coherent scattering length different from the coherent
     |          scattering lengths from ``periodictable``.
     |      r_min : float
     |          The minimum ``r`` (atomic separation) in Angstrom for
     |          which the PDF will be calculated.
     |      r_max : float
     |          The maximum ``r`` (atomic separation) in Angstrom for
     |          which the PDF will be calculated.
     |      r_step : float
     |          The step size of ``r`` (atomic separation) for which the PDF
     |          will be calculated.
     |      r : numpy.ndarray
     |          The uniform ``r`` values in Angstrom for which the PDF
     |          will be calculated.
     |      dimensions : array-like
     |          A 3 element `array-like` (`list`, `tuple`) with the
     |          dimensions of the ``Universe`` in Angstrom.
     |
     |      Notes
     |      -----
     |      If this, ``r_min``, ``r_max``, and ``r_step`` are passed then these
     |      will create a range for the independent variable ``r``,
     |      which will overwrite any ``r`` which has previously been
     |      defined. These cannot be passed if ``r`` is passed.
     |
     |      Examples
     |      --------
     |      To calculate the O-O partial PDF from a simulation of water, use the
     |      subset keyword:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O)])
     |
     |      To calculate the sum of the H-O and O-O partial PDFs:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])
     |
     |      To calculate the total PDF for sodium chloride with 37Cl:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})
     |
     |      To calculate the total PDF for r values of [1., 2., 3., 4.]:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])
     |
     |      To calculate the total PDF over an average of 5 frames:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)
     |
     |  maximum_frames(self) -&gt; None
     |      The maximum number of frames needed to calculate the ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      None
     |          There is no hard limit on the number of frames that can be used, so
     |          return None.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of frames needed to calculate the ``dependent_variables``.
     |
     |      For PDF, this is 1.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`, not
     |          used.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  PDF
     |
     |  PDF_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is the pair distribution function (in ``barn``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The shape of the &#39;PDF&#39; dependent variable in terms of &#39;r&#39;.
     |
     |      Where ``np.shape(self.PDF) == (np.size(self.r))``.
     |
     |      Returns
     |      -------
     |      dict[str, list[str]]
     |          The shape of the PDF dependent variable.
     |
     |  uniformity_requirements
     |      Define the current limitations on the atomic separation distance &#39;r&#39;.
     |
     |      The requirement is that &#39;r&#39; must be uniform, but it does not have to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;r&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the pair distribution function (in ``barn``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      This is the atomic separation distance r (in ``Ang``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  r
     |      Get or set the value of the atomic separation distance (in ``Ang``).
     |
     |      Returns
     |      -------
     |      float
     |          The atomic separation distance.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    class PairDistributionFunction(MDMC.trajectory_analysis.observables.obs.Observable)
     |  Class for processing a pair distribution function (PDF).
     |
     |  We derive our definitions for this from [Keen]_:
     |
     |  We employ the following mathematical form for the total pair
     |  distribution function (``PDF``):
     |
     |  .. math::
     |
     |      G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |  where :math:`c_i` is the number concentration of element :math:`i`,
     |  :math:`b_i` is the (coherent) scattering length of element :math:`i`.
     |  (This corresponds to equation 8 in the above publication)
     |
     |  The partial pair distribution, :math:`g_{ij}`, is:
     |
     |  .. math::
     |
     |      g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |  where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |  atoms around atoms of element :math:`i`, with bins of size
     |  :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |  atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |  :math:`G(0) = -\sum_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |  (This corresponds to equation 10 in the above publication)
     |
     |  The total PDF is contained in ``PDF`` and the partial pair PDFs
     |  (if calculated or imported) are contained in ``partial_pdfs``.
     |
     |  References
     |  ----------
     |  .. [Keen] Keen, D. A.,
     |     &#34;A comparison of various commonly used correlation functions for describing total scattering&#34;
     |     J. Appl. Cryst. 34 (2001) 172-177.
     |
     |     DOI: https://doi.org/10.1107/S0021889800019993
     |
     |  Method resolution order:
     |      PairDistributionFunction
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Methods defined here:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the pair distribution function, :math:`G(r)` from a ``CompactTrajectory``.
     |
     |      The partial pair distribution (from __) for a pair i-j, :math:`g_{ij}`, is:
     |
     |      .. math::
     |
     |          g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}
     |
     |      where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
     |      atoms around atoms of element :math:`i`, with bins of size
     |      :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
     |      atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
     |      :math:`G(0) = -\sum\limits_{i,j}^{N_{elements}} c_ic_jb_ib_j`.
     |
     |      The total pair distribution function (``pdf.PDF``) has the form:
     |
     |      .. math::
     |
     |          G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)
     |
     |      where :math:`c_i` is the proportion of element :math:`i` in the material,
     |      :math:`b_i` is the (coherent) scattering length of element :math:`i`
     |
     |      This corresponds to the equation (10) in the above paper.
     |
     |      Independent variables can either be set previously or defined within
     |      settings.
     |
     |      A number of frames can be specified, from which the ``PDF`` and its
     |      error are calculated. If the number of frames is too large relative to
     |      the run length, the samples will be correlated, which will result in an
     |      underestimate of the error.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          A single ``CompactTrajectory`` object.
     |      verbose : int
     |          Verbose print settings. Not currently implemented for PDF.
     |      **settings
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_frames : int
     |          The number of frames from which the PDF and its error are
     |          calculated. These frames are selected uniformly, and the
     |          step is taken to be n_frames / total number of frames
     |          rounded to the nearest positive integer.
     |
     |          If this is not passed, 1% of the total number of frames
     |          are used (rounded up).
     |      use_average : bool
     |          If set to `False` (default), only the last frame of the
     |          trajectory is used and n_frames will be ignored.
     |
     |          If set to `True` then the mean value for PDF is calculated
     |          across selected frames from the trajectory. Also, the
     |          errors are set to the standard deviation calculated over
     |          the multiple frames.
     |      subset : list of tuples
     |          The subset of element pairs from which the PDF is calculated.
     |
     |          This can be used to calculate the partial PDFs of a
     |          multicomponent system. If this is not passed, all combinations
     |          of elements are used i.e. the PDF is the total PDF.
     |      b_coh : dict
     |          A dictionary containing coherent scattering length values
     |          for one or more elements.
     |
     |          This can be used to calculate
     |          the PDF of a system where one or more elements has a
     |          coherent scattering length different from the coherent
     |          scattering lengths from ``periodictable``.
     |      r_min : float
     |          The minimum ``r`` (atomic separation) in Angstrom for
     |          which the PDF will be calculated.
     |      r_max : float
     |          The maximum ``r`` (atomic separation) in Angstrom for
     |          which the PDF will be calculated.
     |      r_step : float
     |          The step size of ``r`` (atomic separation) for which the PDF
     |          will be calculated.
     |      r : numpy.ndarray
     |          The uniform ``r`` values in Angstrom for which the PDF
     |          will be calculated.
     |      dimensions : array-like
     |          A 3 element `array-like` (`list`, `tuple`) with the
     |          dimensions of the ``Universe`` in Angstrom.
     |
     |      Notes
     |      -----
     |      If this, ``r_min``, ``r_max``, and ``r_step`` are passed then these
     |      will create a range for the independent variable ``r``,
     |      which will overwrite any ``r`` which has previously been
     |      defined. These cannot be passed if ``r`` is passed.
     |
     |      Examples
     |      --------
     |      To calculate the O-O partial PDF from a simulation of water, use the
     |      subset keyword:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O)])
     |
     |      To calculate the sum of the H-O and O-O partial PDFs:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])
     |
     |      To calculate the total PDF for sodium chloride with 37Cl:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})
     |
     |      To calculate the total PDF for r values of [1., 2., 3., 4.]:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])
     |
     |      To calculate the total PDF over an average of 5 frames:
     |
     |      .. code-block:: python
     |
     |          pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)
     |
     |  maximum_frames(self) -&gt; None
     |      The maximum number of frames needed to calculate the ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      None
     |          There is no hard limit on the number of frames that can be used, so
     |          return None.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      The minimum number of frames needed to calculate the ``dependent_variables``.
     |
     |      For PDF, this is 1.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`, not
     |          used.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties defined here:
     |
     |  PDF
     |
     |  PDF_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is the pair distribution function (in ``barn``).
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The shape of the &#39;PDF&#39; dependent variable in terms of &#39;r&#39;.
     |
     |      Where ``np.shape(self.PDF) == (np.size(self.r))``.
     |
     |      Returns
     |      -------
     |      dict[str, list[str]]
     |          The shape of the PDF dependent variable.
     |
     |  uniformity_requirements
     |      Define the current limitations on the atomic separation distance &#39;r&#39;.
     |
     |      The requirement is that &#39;r&#39; must be uniform, but it does not have to start at zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;r&#39;.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      This is the pair distribution function (in ``barn``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      This is the atomic separation distance r (in ``Ang``).
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  r
     |      Get or set the value of the atomic separation distance (in ``Ang``).
     |
     |      Returns
     |      -------
     |      float
     |          The atomic separation distance.
     |
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    class SQw(AbstractSQw)
     |  A class for the total dynamic structure factor.
     |
     |  Calculation is done in the respective FQt object, and this is
     |  just a reference to get the correct FQt object.
     |
     |  Method resolution order:
     |      SQw
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    SQwCoh = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    SQwIncoherentSQwIncoh = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    SQw_coh = class SQwCoherent(AbstractSQw)
     |  A class for the coherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwCoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

    SQw_incoh = class SQwIncoherent(AbstractSQw)
     |  A class for the incoherent dynamic structure factor.
     |
     |  Method resolution order:
     |      SQwIncoherent
     |      AbstractSQw
     |      SQwMixins
     |      MDMC.trajectory_analysis.observables.obs.Observable
     |      abc.ABC
     |      builtins.object
     |
     |  Data and other attributes defined here:
     |
     |  __abstractmethods__ = frozenset()
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from AbstractSQw:
     |
     |  __init__(self)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |
     |  calculate_dt(self) -&gt; float
     |      Calculate timestep required by experimental dataset assuming uniform spacing.
     |
     |      .. note::
     |
     |         This may be different from the time separation that the
     |         user has given as an input, as it only depends on the
     |         current values for ``self.E``.
     |
     |      The relationship between time and energy comes from the numpy
     |      implementation of the FFT for ``2 * nE`` points where:
     |
     |      .. math:: \nu_{max} &amp;=&amp; \frac{n_E - 1}{2 n_E \Delta t} \\\\
     |          \therefore \Delta t &amp;=&amp; \frac{h (n_E - 1)}{2 n_E E_{max}}
     |
     |      Returns
     |      -------
     |      float
     |          The time separation required by the current values of ``self.E``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fft : Numpy FFT implementation.
     |
     |  calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
     |      Calculate the dynamic structure factor, S(Q, w) from a ``CompactTrajectory``.
     |
     |      If the ``CompactTrajectory`` has more frames than the
     |      ``self.maximum_frames()`` that can be used to recreate the
     |      grid of energy points, it can slice the ``CompactTrajectory``
     |      into sub-trajectories of length ``self.maximum_frames()``,
     |      with the slicing specified through the settings
     |      ``use_average`` and ``cont_slicing``.
     |
     |      The ``independent_variable`` ``Q`` can either be set
     |      previously or defined within ``**settings``.
     |
     |      Parameters
     |      ----------
     |      MD_input : CompactTrajectory
     |          An MDMC ``CompactTrajectory`` from which to calculate ``SQw``.
     |      verbose : int, optional
     |          The level of verbosity:
     |
     |          - Verbose level 0 gives no information.
     |          - Verbose level 1 gives final time for the whole method.
     |          - Verbose level 2 gives final time and also a progress bar.
     |          - Verbose level 3 gives final time, a progress bar, and time per step.
     |      **settings : dict
     |          Extra options.
     |
     |      Other Parameters
     |      ----------------
     |      n_Q_vectors : int
     |          The maximum number of ``Q_vectors`` for any ``Q`` value. The
     |          greater the number of ``Q_vectors``, the more accurate the
     |          calculation, but the longer it will take.
     |      dimensions : list, tuple or numpy.ndarray
     |          A 3 element `tuple` or ``array`` of `float` specifying the
     |          dimensions of the ``Universe`` in units of ``Ang``.
     |      energy_resolution : dict
     |          Specify energy resolution and function in units
     |          of ueV (micro eV), in the format of the one-line dict
     |          {&#39;function&#39;: value}, where `function` is the resolution
     |          function and `value` is the desired `FWHM`.
     |
     |          For example, to pass a Gaussian resolution of 80ueV we use
     |          {&#39;gaussian&#39;: 80}.
     |
     |          Currently accepted functions are &#39;gaussian&#39; and
     |          &#39;lorentzian&#39; Can also be &#39;lazily&#39; given as `float`, in
     |          which case it is assumed to be Gaussian.
     |      Q_values : numpy.ndarray
     |          1D array of Q `float` (in ``Ang^-1``).
     |      use_average : bool
     |          Optional parameter if a list of more than one ``Trajectory``
     |          is used.
     |
     |          If set to True (default) then the mean value for S(Q, w)
     |          is calculated. Also, the errors are set to the standard
     |          deviation calculated over the list of
     |          ``CompactTrajectory`` objects.
     |      cont_slicing : bool
     |
     |          Flag to decide between two possible behaviours when the
     |          number of ``MD_steps`` is larger than the minimum required
     |          to calculate the observables.
     |
     |          If ``False`` (default) then the ``CompactTrajectory`` is
     |          sliced into non-overlapping sub-``CompactTrajectory``
     |          blocks for each of which the observable is calculated.
     |
     |          If ``True``, then the ``CompactTrajectory`` is sliced into
     |          as many non-identical sub-``CompactTrajectory`` blocks as
     |          possible (with overlap allowed).
     |
     |  calculate_resolution_functions(self, dt: float) -&gt; dict
     |      Generate resolution function in momentum and time.
     |
     |      Parameters
     |      ----------
     |      dt : float
     |          The time spacing for the inverse Fourier transform (in ``fs``).
     |
     |          Ideally this should be the same as the frame separation
     |          expected when applying this function.
     |
     |      Returns
     |      -------
     |      dict
     |          A dictionary with the key &#39;SQw&#39; corresponding to function
     |          which accepts arrays of time and momentum (respectively)
     |          and returns a 2D array of values for the instrument
     |          resolution.
     |
     |      Notes
     |      -----
     |      There are several caveats to this function a user should be aware of:
     |
     |      - This uses the ``SQw`` values of the ``Observable`` it is
     |        called from, and so should only be called for an observable
     |        which has been created from relevant resolution data,
     |        i.e. a vanadium sample.
     |      - If this resolution function is used on data outside
     |        its original range, then it will use nearest neighbour
     |        extrapolation.
     |      - The input will be reflected in the time/energy domain as
     |        symmetry about 0 is assumed.
     |
     |      If for whatever reason this is not appropriate for the data in
     |      question, this function should not be used.
     |
     |  validate_energy(self, time_step: float = None)
     |      Ensure ``dt`` is valid for computing energies.
     |
     |      Asserts that the user set frame separation ``dt`` leads to energy
     |      separation that matches that of the experiment. If not, it
     |      changes the time step and trajectory step to fix this. The time step value is
     |      prioritised here.
     |
     |      Parameters
     |      ----------
     |      time_step : float, optional
     |          User specified length of time for each update of the atoms trajectories
     |          in the simulation, default is None.
     |
     |      Returns
     |      -------
     |      valid : bool
     |          Whether ``dt`` is valid.
     |      traj_step : Optional[int]
     |          Ideal ``traj_step`` if provided.
     |      time_step : Optional[float]
     |          Ideal ``time_step`` if provided.
     |      dt : float
     |          Required ``dt``.
     |
     |  ----------------------------------------------------------------------
     |  Static methods inherited from AbstractSQw:
     |
     |  calculate_E(nE: int, dt: float) -&gt; numpy.ndarray
     |      Compute energy from MD.
     |
     |      Calculate an array of ``nE`` uniformly spaced energy values from the
     |      time separation of the ``CompactTrajectory`` frames, ``dt``.
     |
     |      The frequencies are determined by the fast Fourier transform,
     |      as implemented by numpy, for ``2 * nE`` points in time which
     |      are truncated to only include ``nE`` positive frequencies.
     |
     |      As we are dealing with frequency rather than angular frequency
     |      here, the relation to between energy is given by:
     |
     |      .. math::
     |
     |          E = h \nu
     |
     |      Parameters
     |      ----------
     |      nE : int
     |          The number of energy values to be calculated.
     |      dt : float
     |          The step size between frames in ``fs``.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          An ``array`` of `float` specifying the energy in units of ``meV``.
     |
     |      See Also
     |      --------
     |      numpy.fft.fftfreq : Frequency calculation.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from AbstractSQw:
     |
     |  E
     |
     |  SQw
     |
     |  SQw_err
     |
     |  dependent_variables
     |      Get the dependent variables.
     |
     |      This is:
     |
     |      - SQw, the dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The dependent variables.
     |
     |  dependent_variables_structure
     |      The order in which the &#39;SQw&#39; dependent variable is indexed in terms of &#39;Q&#39; and &#39;E&#39;.
     |
     |      The purpose of this method is to ensure consistency
     |      between different readers/methods which create ``SQw`` objects.
     |
     |      Returns
     |      -------
     |      dict[str, list]
     |          The shape of the SQw dependent variable.
     |
     |      Notes
     |      -----
     |      Explicitly: we have that self.SQw[Q_index, E_index] is the data point for
     |      given indices of self.Q and self.E.
     |
     |      It also means that:
     |      np.shape(self.SQw)=(np.size(self.Q), np.size(self.E)).
     |
     |  uniformity_requirements
     |      Get restrictions required for computing E &amp; Q.
     |
     |      Captures the current limitations on the energy &#39;E&#39; and reciprocal
     |      lattice points &#39;Q&#39; within the dynamic structure factor ``Observables``.
     |      If using FFT, then &#39;E&#39; must be uniform and start at zero, otherwise it
     |      has no restrictions. &#39;Q&#39; must be uniform but does not need to start at
     |      zero.
     |
     |      Returns
     |      -------
     |      dict[str, dict[str, bool]]
     |          Dictionary of uniformity restrictions for &#39;E&#39; and &#39;Q&#39;.
     |
     |  w
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from AbstractSQw:
     |
     |  errors
     |      Get or set the errors on the dependent variables.
     |
     |      The dynamic structure factor (in ``arb``)
     |
     |      Returns
     |      -------
     |      dict
     |          The errors on the ``dependent_variables``.
     |
     |  independent_variables
     |      Get or set the independent variables.
     |
     |      These are:
     |
     |      - the frequency :math:`Q` (in ``Ang^-1``)
     |      - energy :math:`E` (in``meV``)
     |
     |      Returns
     |      -------
     |      dict
     |          The independent variables.
     |
     |  recreated_Q
     |      Get the indices of the recreated Q_values.
     |
     |      Returns
     |      -------
     |      numpy.ndarray
     |          Array of recreated Q values.
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from SQwMixins:
     |
     |  maximum_frames(self) -&gt; Optional[int]
     |      Compute maximum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Returns
     |      -------
     |      int
     |          The maximum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on `self.use_FFT`.
     |
     |      If `True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      Otherwise, there is no limit and all frames will contribute to the
     |      calculation.
     |
     |  minimum_frames(self, dt: float = None) -&gt; int
     |      Compute minimum number of ``CompactTrajectory`` frames to calculate ``dependent_variables``.
     |
     |      Parameters
     |      ----------
     |      dt : float, optional
     |          The time separation of frames in ``fs``, default is `None`.
     |
     |      Returns
     |      -------
     |      int
     |          The minimum number of frames.
     |
     |      Notes
     |      -----
     |      Depends on ``self.use_FFT``.
     |
     |      If `self.use_FFT == True`, it is the number of energy steps + 1, in order to allow for
     |      a reflection in time which only counts the end points once.
     |
     |      If `self.use_FFT == False`, there is not a hard minimum on number of frames. However, to
     |      distinguish our smallest differences in energy :math:`F(Q,t)` needs to
     |      cover at least a time period :math:`T_{min}` such that:
     |
     |      .. math::
     |
     |          T_{min} \sim \frac{h}{\Delta E_{min}}
     |
     |      Due to the aforementioned reflection in the time domain, to cover a
     |      period of :math:`T_{min}` we only need :math:`N` frames:
     |
     |      .. math::
     |
     |          N = \frac{T_{min}}{2 \Delta t} + 1 = \frac{h}{2 \Delta t \Delta E_{min}} + 1
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from SQwMixins:
     |
     |  Q
     |
     |  __dict__
     |      dictionary for instance variables
     |
     |  __weakref__
     |      list of weak references to the object
     |
     |  ----------------------------------------------------------------------
     |  Methods inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  __repr__(self) from MDMC.common.decorators.repr_decorator.&lt;locals&gt;.decorator.&lt;locals&gt;
     |
     |  read_from_file(self, reader: str, file_name: str) -&gt; None
     |      Read in experimental data from a file using a specified reader.
     |
     |      Parameters
     |      ----------
     |      reader : str
     |          The name of the required file reader.
     |      file_name : str
     |          The name of the file.
     |
     |  ----------------------------------------------------------------------
     |  Readonly properties inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  data
     |      Get the independent, dependent and error data.
     |
     |      Returns
     |      -------
     |      dict
     |          The independent, dependent and error data.
     |
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from MDMC.trajectory_analysis.observables.obs.Observable:
     |
     |  name
     |      Get or set the module name that used for factory instantiation.
     |
     |      Returns
     |      -------
     |      str
     |          The name of the module in which the ``Observable`` is located.
     |
     |  origin
     |      Get or set the origin of the observable.
     |
     |      Returns
     |      -------
     |      {&#39;experiment&#39;, &#39;MD&#39;}
     |          The origin of the ``Observable``, either ``&#39;experiment&#39;`` or ``&#39;MD&#39;``.
     |
     |  use_FFT
     |      Get or set whether to use FFT when calculating from MD.
     |
     |      Returns
     |      -------
     |      bool
     |          Whether to use FFT.

DATA
    __all__ = [&#39;CoherentDynamicStructureFactor&#39;, &#39;CoherentIntermediateScat...

FILE
    /usr/local/lib/python3.12/site-packages/MDMC/trajectory_analysis/observables/__init__.py


</pre></div></div>
</div>
<p>Each observable may have one or more aliases - both <code class="docutils literal notranslate"><span class="pre">DynamicStructureFactor</span></code> or <code class="docutils literal notranslate"><span class="pre">SQw</span></code> can be used for calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span>.</p>
<p>Some of the details given below are specific to calculating the dynamic structure factor, however the general method can be followed for any observable.</p>
<p>Argon has comparable scattering lengths for both coherent and incoherent scattering, so the total scattering has clear contributions from each. For the purposes of this tutorial we will simply calculate <span class="math notranslate nohighlight">\(S(Q,\omega)_{coh}\)</span> and compare it with experimental data; calculating the incoherent and total scattering can be done similarly with the objects <code class="docutils literal notranslate"><span class="pre">observables.SQwIncoh</span></code> or <code class="docutils literal notranslate"><span class="pre">observables.SQw</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span> <span class="o">=</span> <span class="n">observables</span><span class="o">.</span><span class="n">SQwCoh</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>The dynamic structure factor has two independent variables; the scattering wavevector <span class="math notranslate nohighlight">\(Q\)</span>, and the energy transfer <span class="math notranslate nohighlight">\(\omega\)</span> (or <span class="math notranslate nohighlight">\(E/\hbar\)</span> where <span class="math notranslate nohighlight">\(\hbar\)</span> denotes the reduced Planck constant).</p>
<p>The size of the simulation box defines the spacing (and therefore the lower bound) of <span class="math notranslate nohighlight">\(Q\)</span> values; however any Q values can be specified for calculating <span class="math notranslate nohighlight">\(S(Q,\omega)\)</span> and MDMC will simply calculate it for valid values.</p>
<p>Here, we use the <code class="docutils literal notranslate"><span class="pre">np.arange</span></code> function to create an array of Q-values, evenly spaced in steps of 0.3 between 0.42 and 3.8.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mf">0.42</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mf">3.8</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Q will be calculated for values of: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Q</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Q will be calculated for values of: [0.42 0.72 1.02 1.32 1.62 1.92 2.22 2.52 2.82 3.12 3.42 3.72]
</pre></div></div>
</div>
<p>The total duration of the trajectory defines the smallest spacing of the <span class="math notranslate nohighlight">\(E\)</span> values. If <span class="math notranslate nohighlight">\(E\)</span> values are not specified, MDMC will simply calculate the <span class="math notranslate nohighlight">\(E\)</span> values with this spacing. However for this setting there will only be two points in the trajectory contributing to each energy bin and the statistics will be poor.</p>
<p><strong>should take ~30s to execute</strong>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set the Q values for the Q independent variable</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">independent_variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">}</span>

<span class="c1"># Calculate the coherent dynamic structure factor</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>and indeed, the plot betrays our poor statistics:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        // There's no need to resize if the WebSocket is not connected:
        // - If it is still connecting, then we will get an initial resize from
        //   Python once it connects.
        // - If it has disconnected, then resizing will clear the canvas and
        //   never get anything back to refill it, so better to not resize and
        //   keep something visible.
        if (fig.ws.readyState != 1) {
            return;
        }
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '%s' message type: ",
                msg_type,
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '%s' message: ", msg_type, msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_%s' callback:",
                    msg_type,
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        buttons: event.buttons,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='3d9e92e6-7031-481e-ac05-8a951a629ec1'></div></div>
</div>
<p>Therefore it is strongly recommended that you specify the <span class="math notranslate nohighlight">\(E\)</span> values for calculating the dynamic structure factor.</p>
<p>The allowed values of <span class="math notranslate nohighlight">\(E\)</span> (in meV) are determined by trajectory times. To aid in calculating these, the <code class="docutils literal notranslate"><span class="pre">calculate_E</span></code> method can be used, which requires the time step of the trajectory (in fs) and the total number of E values to be calculated. The number of E values should be changed to improve the statistics, but somewhere in the range of 1/4 to 1/8 of the total number of trajectory configurations (i.e. the number of times for which a configuration was recorded) will often be
reasonable:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This subtracts the time of the zeroeth step from the time of the first step</span>
<span class="c1"># It should be equal to the time_step * traj_step passed to Simulation</span>
<span class="n">trajectory_timestep</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;CompactTrajectory time step: </span><span class="si">{}</span><span class="s1"> fs&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">trajectory_timestep</span><span class="p">))</span>

<span class="n">n_configurations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Number of trajectory configurations: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_configurations</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
CompactTrajectory time step: 250.0 fs
Number of trajectory configurations: 481
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_E</span><span class="p">((</span><span class="n">n_configurations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">,</span> <span class="n">trajectory_timestep</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculated E values are: </span><span class="se">\n</span><span class="si">{}</span><span class="s1"> meV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">E</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Calculated E values are:
[0.         0.10339169 0.20678338 0.31017508 0.41356677 0.51695846
 0.62035015 0.72374185 0.82713354 0.93052523 1.03391692 1.13730862
 1.24070031 1.344092   1.44748369 1.55087539 1.65426708 1.75765877
 1.86105046 1.96444216 2.06783385 2.17122554 2.27461723 2.37800893
 2.48140062 2.58479231 2.688184   2.79157569 2.89496739 2.99835908
 3.10175077 3.20514246 3.30853416 3.41192585 3.51531754 3.61870923
 3.72210093 3.82549262 3.92888431 4.032276   4.1356677  4.23905939
 4.34245108 4.44584277 4.54923447 4.65262616 4.75601785 4.85940954
 4.96280124 5.06619293 5.16958462 5.27297631 5.376368   5.4797597
 5.58315139 5.68654308 5.78993477 5.89332647 5.99671816 6.10010985
 6.20350154 6.30689324 6.41028493 6.51367662 6.61706831 6.72046001
 6.8238517  6.92724339 7.03063508 7.13402678 7.23741847 7.34081016
 7.44420185 7.54759355 7.65098524 7.75437693 7.85776862 7.96116031
 8.06455201 8.1679437 ] meV
</pre></div></div>
</div>
<p>Of course if the <span class="math notranslate nohighlight">\(E\)</span> resolution required is lower (i.e. step between the <code class="docutils literal notranslate"><span class="pre">E</span></code> values can be larger), the number of E values specified can be reduced:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A reduced E resolution: </span><span class="se">\n</span><span class="si">{}</span><span class="s1"> meV&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_E</span><span class="p">((</span><span class="n">n_configurations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">24</span><span class="p">,</span> <span class="n">trajectory_timestep</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
A reduced E resolution:
[0.         0.41356677 0.82713354 1.24070031 1.65426708 2.06783385
 2.48140062 2.89496739 3.30853416 3.72210093 4.1356677  4.54923447
 4.96280124 5.376368   5.78993477 6.20350154 6.61706831 7.03063508
 7.44420185 7.85776862] meV
</pre></div></div>
</div>
<p>Now we can use <code class="docutils literal notranslate"><span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">E</span></code> to set the indepedendent variables of <code class="docutils literal notranslate"><span class="pre">sqw_coh</span></code>:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">independent_variables</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;E&#39;</span><span class="p">:</span><span class="n">E</span><span class="p">,</span>
                                 <span class="s1">&#39;Q&#39;</span><span class="p">:</span><span class="n">Q</span><span class="p">}</span>
</pre></div>
</div>
</div>
<p>Using this binning, we recalculate the dynamic structure factor, which is smoother due to better statistics.</p>
<p><strong>This calculation should take ~30s.</strong>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)</span>
<span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        // There's no need to resize if the WebSocket is not connected:
        // - If it is still connecting, then we will get an initial resize from
        //   Python once it connects.
        // - If it has disconnected, then resizing will clear the canvas and
        //   never get anything back to refill it, so better to not resize and
        //   keep something visible.
        if (fig.ws.readyState != 1) {
            return;
        }
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '%s' message type: ",
                msg_type,
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '%s' message: ", msg_type, msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_%s' callback:",
                    msg_type,
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        buttons: event.buttons,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='f7722966-4e75-45ea-a69e-ab3289e7dab3'></div></div>
</div>
<p>We can compare this with experimental data measured using quasi-elastic neutron scattering (QENS) data (specifically here the <a class="reference external" href="https://doi.org/10.1103/PhysRevA.31.3391">van Well et al. (1985)</a> data, seen in detail in the <a class="reference internal" href="../../../tutorials/Argon-a-to-z.html"><span class="doc">Argon a-to-z</span></a> tutorial) by reading the data into an SQwCoh object:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sqw_exp</span> <span class="o">=</span> <span class="n">observables</span><span class="o">.</span><span class="n">SQwCoh</span><span class="p">()</span><span class="o">.</span><span class="n">read_from_file</span><span class="p">(</span><span class="n">reader</span><span class="o">=</span><span class="s1">&#39;xml_SQw&#39;</span><span class="p">,</span> <span class="n">file_name</span><span class="o">=</span><span class="s1">&#39;./data/Well_s_q_omega_Ar_data.xml&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The independent and dependent variables are read into the same attributes (<code class="docutils literal notranslate"><span class="pre">sqw_exp.E</span></code>, <code class="docutils literal notranslate"><span class="pre">sqw_exp.Q</span></code>, and <code class="docutils literal notranslate"><span class="pre">sqw_exp.SQw</span></code>) as if they had been calculated from MD (as in <code class="docutils literal notranslate"><span class="pre">sqw_coh</span></code> above).</p>
<p>For many QENS datasets (if not most) the instrument resolution has not been removed, and to compare with MD simulation this requires the simulation output to be smoothed to the instrument resolution. One way this can be done is using the optional <code class="docutils literal notranslate"><span class="pre">energy_resolution</span></code>:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># energy_resolution is the FWHM of the instrumentation&#39;s resolution function expressed in ueV (micro eV).</span>
<span class="c1"># It is used to smooth the calculated S(Q,w) with a Gaussian window in order to match the values obtained experimentally.</span>
<span class="n">sqw_coh</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">(</span><span class="n">trajectory</span><span class="p">,</span> <span class="n">energy_resolution</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;gaussian&#39;</span><span class="p">:</span> <span class="mf">1.0e3</span><span class="p">})</span>

<span class="n">plot_surface</span><span class="p">(</span><span class="n">sqw_coh</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">Q</span><span class="p">,</span> <span class="n">sqw_coh</span><span class="o">.</span><span class="n">SQw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="output_javascript"></div>
<script type="text/javascript">
var element = document.currentScript.previousSibling.previousSibling;
/* Put everything inside the global mpl namespace */
/* global mpl */
window.mpl = {};

mpl.get_websocket_type = function () {
    if (typeof WebSocket !== 'undefined') {
        return WebSocket;
    } else if (typeof MozWebSocket !== 'undefined') {
        return MozWebSocket;
    } else {
        alert(
            'Your browser does not have WebSocket support. ' +
                'Please try Chrome, Safari or Firefox ≥ 6. ' +
                'Firefox 4 and 5 are also supported but you ' +
                'have to enable WebSockets in about:config.'
        );
    }
};

mpl.figure = function (figure_id, websocket, ondownload, parent_element) {
    this.id = figure_id;

    this.ws = websocket;

    this.supports_binary = this.ws.binaryType !== undefined;

    if (!this.supports_binary) {
        var warnings = document.getElementById('mpl-warnings');
        if (warnings) {
            warnings.style.display = 'block';
            warnings.textContent =
                'This browser does not support binary websocket messages. ' +
                'Performance may be slow.';
        }
    }

    this.imageObj = new Image();

    this.context = undefined;
    this.message = undefined;
    this.canvas = undefined;
    this.rubberband_canvas = undefined;
    this.rubberband_context = undefined;
    this.format_dropdown = undefined;

    this.image_mode = 'full';

    this.root = document.createElement('div');
    this.root.setAttribute('style', 'display: inline-block');
    this._root_extra_style(this.root);

    parent_element.appendChild(this.root);

    this._init_header(this);
    this._init_canvas(this);
    this._init_toolbar(this);

    var fig = this;

    this.waiting = false;

    this.ws.onopen = function () {
        fig.send_message('supports_binary', { value: fig.supports_binary });
        fig.send_message('send_image_mode', {});
        if (fig.ratio !== 1) {
            fig.send_message('set_device_pixel_ratio', {
                device_pixel_ratio: fig.ratio,
            });
        }
        fig.send_message('refresh', {});
    };

    this.imageObj.onload = function () {
        if (fig.image_mode === 'full') {
            // Full images could contain transparency (where diff images
            // almost always do), so we need to clear the canvas so that
            // there is no ghosting.
            fig.context.clearRect(0, 0, fig.canvas.width, fig.canvas.height);
        }
        fig.context.drawImage(fig.imageObj, 0, 0);
    };

    this.imageObj.onunload = function () {
        fig.ws.close();
    };

    this.ws.onmessage = this._make_on_message_function(this);

    this.ondownload = ondownload;
};

mpl.figure.prototype._init_header = function () {
    var titlebar = document.createElement('div');
    titlebar.classList =
        'ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix';
    var titletext = document.createElement('div');
    titletext.classList = 'ui-dialog-title';
    titletext.setAttribute(
        'style',
        'width: 100%; text-align: center; padding: 3px;'
    );
    titlebar.appendChild(titletext);
    this.root.appendChild(titlebar);
    this.header = titletext;
};

mpl.figure.prototype._canvas_extra_style = function (_canvas_div) {};

mpl.figure.prototype._root_extra_style = function (_canvas_div) {};

mpl.figure.prototype._init_canvas = function () {
    var fig = this;

    var canvas_div = (this.canvas_div = document.createElement('div'));
    canvas_div.setAttribute('tabindex', '0');
    canvas_div.setAttribute(
        'style',
        'border: 1px solid #ddd;' +
            'box-sizing: content-box;' +
            'clear: both;' +
            'min-height: 1px;' +
            'min-width: 1px;' +
            'outline: 0;' +
            'overflow: hidden;' +
            'position: relative;' +
            'resize: both;' +
            'z-index: 2;'
    );

    function on_keyboard_event_closure(name) {
        return function (event) {
            return fig.key_event(event, name);
        };
    }

    canvas_div.addEventListener(
        'keydown',
        on_keyboard_event_closure('key_press')
    );
    canvas_div.addEventListener(
        'keyup',
        on_keyboard_event_closure('key_release')
    );

    this._canvas_extra_style(canvas_div);
    this.root.appendChild(canvas_div);

    var canvas = (this.canvas = document.createElement('canvas'));
    canvas.classList.add('mpl-canvas');
    canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'pointer-events: none;' +
            'position: relative;' +
            'z-index: 0;'
    );

    this.context = canvas.getContext('2d');

    var backingStore =
        this.context.backingStorePixelRatio ||
        this.context.webkitBackingStorePixelRatio ||
        this.context.mozBackingStorePixelRatio ||
        this.context.msBackingStorePixelRatio ||
        this.context.oBackingStorePixelRatio ||
        this.context.backingStorePixelRatio ||
        1;

    this.ratio = (window.devicePixelRatio || 1) / backingStore;

    var rubberband_canvas = (this.rubberband_canvas = document.createElement(
        'canvas'
    ));
    rubberband_canvas.setAttribute(
        'style',
        'box-sizing: content-box;' +
            'left: 0;' +
            'pointer-events: none;' +
            'position: absolute;' +
            'top: 0;' +
            'z-index: 1;'
    );

    // Apply a ponyfill if ResizeObserver is not implemented by browser.
    if (this.ResizeObserver === undefined) {
        if (window.ResizeObserver !== undefined) {
            this.ResizeObserver = window.ResizeObserver;
        } else {
            var obs = _JSXTOOLS_RESIZE_OBSERVER({});
            this.ResizeObserver = obs.ResizeObserver;
        }
    }

    this.resizeObserverInstance = new this.ResizeObserver(function (entries) {
        // There's no need to resize if the WebSocket is not connected:
        // - If it is still connecting, then we will get an initial resize from
        //   Python once it connects.
        // - If it has disconnected, then resizing will clear the canvas and
        //   never get anything back to refill it, so better to not resize and
        //   keep something visible.
        if (fig.ws.readyState != 1) {
            return;
        }
        var nentries = entries.length;
        for (var i = 0; i < nentries; i++) {
            var entry = entries[i];
            var width, height;
            if (entry.contentBoxSize) {
                if (entry.contentBoxSize instanceof Array) {
                    // Chrome 84 implements new version of spec.
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // Firefox implements old version of spec.
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // Chrome <84 implements even older version of spec.
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }

            // Keep the size of the canvas and rubber band canvas in sync with
            // the canvas container.
            if (entry.devicePixelContentBoxSize) {
                // Chrome 84 implements new version of spec.
                canvas.setAttribute(
                    'width',
                    entry.devicePixelContentBoxSize[0].inlineSize
                );
                canvas.setAttribute(
                    'height',
                    entry.devicePixelContentBoxSize[0].blockSize
                );
            } else {
                canvas.setAttribute('width', width * fig.ratio);
                canvas.setAttribute('height', height * fig.ratio);
            }
            /* This rescales the canvas back to display pixels, so that it
             * appears correct on HiDPI screens. */
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            rubberband_canvas.setAttribute('width', width);
            rubberband_canvas.setAttribute('height', height);

            // And update the size in Python. We ignore the initial 0/0 size
            // that occurs as the element is placed into the DOM, which should
            // otherwise not happen due to the minimum size styling.
            if (width != 0 && height != 0) {
                fig.request_resize(width, height);
            }
        }
    });
    this.resizeObserverInstance.observe(canvas_div);

    function on_mouse_event_closure(name) {
        /* User Agent sniffing is bad, but WebKit is busted:
         * https://bugs.webkit.org/show_bug.cgi?id=144526
         * https://bugs.webkit.org/show_bug.cgi?id=181818
         * The worst that happens here is that they get an extra browser
         * selection when dragging, if this check fails to catch them.
         */
        var UA = navigator.userAgent;
        var isWebKit = /AppleWebKit/.test(UA) && !/Chrome/.test(UA);
        if(isWebKit) {
            return function (event) {
                /* This prevents the web browser from automatically changing to
                 * the text insertion cursor when the button is pressed. We
                 * want to control all of the cursor setting manually through
                 * the 'cursor' event from matplotlib */
                event.preventDefault()
                return fig.mouse_event(event, name);
            };
        } else {
            return function (event) {
                return fig.mouse_event(event, name);
            };
        }
    }

    canvas_div.addEventListener(
        'mousedown',
        on_mouse_event_closure('button_press')
    );
    canvas_div.addEventListener(
        'mouseup',
        on_mouse_event_closure('button_release')
    );
    canvas_div.addEventListener(
        'dblclick',
        on_mouse_event_closure('dblclick')
    );
    // Throttle sequential mouse events to 1 every 20ms.
    canvas_div.addEventListener(
        'mousemove',
        on_mouse_event_closure('motion_notify')
    );

    canvas_div.addEventListener(
        'mouseenter',
        on_mouse_event_closure('figure_enter')
    );
    canvas_div.addEventListener(
        'mouseleave',
        on_mouse_event_closure('figure_leave')
    );

    canvas_div.addEventListener('wheel', function (event) {
        if (event.deltaY < 0) {
            event.step = 1;
        } else {
            event.step = -1;
        }
        on_mouse_event_closure('scroll')(event);
    });

    canvas_div.appendChild(canvas);
    canvas_div.appendChild(rubberband_canvas);

    this.rubberband_context = rubberband_canvas.getContext('2d');
    this.rubberband_context.strokeStyle = '#000000';

    this._resize_canvas = function (width, height, forward) {
        if (forward) {
            canvas_div.style.width = width + 'px';
            canvas_div.style.height = height + 'px';
        }
    };

    // Disable right mouse context menu.
    canvas_div.addEventListener('contextmenu', function (_e) {
        event.preventDefault();
        return false;
    });

    function set_focus() {
        canvas.focus();
        canvas_div.focus();
    }

    window.setTimeout(set_focus, 100);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'mpl-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'mpl-button-group';
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'mpl-button-group';
            continue;
        }

        var button = (fig.buttons[name] = document.createElement('button'));
        button.classList = 'mpl-widget';
        button.setAttribute('role', 'button');
        button.setAttribute('aria-disabled', 'false');
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));

        var icon_img = document.createElement('img');
        icon_img.src = '_images/' + image + '.png';
        icon_img.srcset = '_images/' + image + '_large.png 2x';
        icon_img.alt = tooltip;
        button.appendChild(icon_img);

        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    var fmt_picker = document.createElement('select');
    fmt_picker.classList = 'mpl-widget';
    toolbar.appendChild(fmt_picker);
    this.format_dropdown = fmt_picker;

    for (var ind in mpl.extensions) {
        var fmt = mpl.extensions[ind];
        var option = document.createElement('option');
        option.selected = fmt === mpl.default_extension;
        option.innerHTML = fmt;
        fmt_picker.appendChild(option);
    }

    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message';
    toolbar.appendChild(status_bar);
    this.message = status_bar;
};

mpl.figure.prototype.request_resize = function (x_pixels, y_pixels) {
    // Request matplotlib to resize the figure. Matplotlib will then trigger a resize in the client,
    // which will in turn request a refresh of the image.
    this.send_message('resize', { width: x_pixels, height: y_pixels });
};

mpl.figure.prototype.send_message = function (type, properties) {
    properties['type'] = type;
    properties['figure_id'] = this.id;
    this.ws.send(JSON.stringify(properties));
};

mpl.figure.prototype.send_draw_message = function () {
    if (!this.waiting) {
        this.waiting = true;
        this.ws.send(JSON.stringify({ type: 'draw', figure_id: this.id }));
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    var format_dropdown = fig.format_dropdown;
    var format = format_dropdown.options[format_dropdown.selectedIndex].value;
    fig.ondownload(fig, format);
};

mpl.figure.prototype.handle_resize = function (fig, msg) {
    var size = msg['size'];
    if (size[0] !== fig.canvas.width || size[1] !== fig.canvas.height) {
        fig._resize_canvas(size[0], size[1], msg['forward']);
        fig.send_message('refresh', {});
    }
};

mpl.figure.prototype.handle_rubberband = function (fig, msg) {
    var x0 = msg['x0'] / fig.ratio;
    var y0 = (fig.canvas.height - msg['y0']) / fig.ratio;
    var x1 = msg['x1'] / fig.ratio;
    var y1 = (fig.canvas.height - msg['y1']) / fig.ratio;
    x0 = Math.floor(x0) + 0.5;
    y0 = Math.floor(y0) + 0.5;
    x1 = Math.floor(x1) + 0.5;
    y1 = Math.floor(y1) + 0.5;
    var min_x = Math.min(x0, x1);
    var min_y = Math.min(y0, y1);
    var width = Math.abs(x1 - x0);
    var height = Math.abs(y1 - y0);

    fig.rubberband_context.clearRect(
        0,
        0,
        fig.canvas.width / fig.ratio,
        fig.canvas.height / fig.ratio
    );

    fig.rubberband_context.strokeRect(min_x, min_y, width, height);
};

mpl.figure.prototype.handle_figure_label = function (fig, msg) {
    // Updates the figure title.
    fig.header.textContent = msg['label'];
};

mpl.figure.prototype.handle_cursor = function (fig, msg) {
    fig.canvas_div.style.cursor = msg['cursor'];
};

mpl.figure.prototype.handle_message = function (fig, msg) {
    fig.message.textContent = msg['message'];
};

mpl.figure.prototype.handle_draw = function (fig, _msg) {
    // Request the server to send over a new figure.
    fig.send_draw_message();
};

mpl.figure.prototype.handle_image_mode = function (fig, msg) {
    fig.image_mode = msg['mode'];
};

mpl.figure.prototype.handle_history_buttons = function (fig, msg) {
    for (var key in msg) {
        if (!(key in fig.buttons)) {
            continue;
        }
        fig.buttons[key].disabled = !msg[key];
        fig.buttons[key].setAttribute('aria-disabled', !msg[key]);
    }
};

mpl.figure.prototype.handle_navigate_mode = function (fig, msg) {
    if (msg['mode'] === 'PAN') {
        fig.buttons['Pan'].classList.add('active');
        fig.buttons['Zoom'].classList.remove('active');
    } else if (msg['mode'] === 'ZOOM') {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.add('active');
    } else {
        fig.buttons['Pan'].classList.remove('active');
        fig.buttons['Zoom'].classList.remove('active');
    }
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Called whenever the canvas gets updated.
    this.send_message('ack', {});
};

// A function to construct a web socket function for onmessage handling.
// Called in the figure constructor.
mpl.figure.prototype._make_on_message_function = function (fig) {
    return function socket_on_message(evt) {
        if (evt.data instanceof Blob) {
            var img = evt.data;
            if (img.type !== 'image/png') {
                /* FIXME: We get "Resource interpreted as Image but
                 * transferred with MIME type text/plain:" errors on
                 * Chrome.  But how to set the MIME type?  It doesn't seem
                 * to be part of the websocket stream */
                img.type = 'image/png';
            }

            /* Free the memory for the previous frames */
            if (fig.imageObj.src) {
                (window.URL || window.webkitURL).revokeObjectURL(
                    fig.imageObj.src
                );
            }

            fig.imageObj.src = (window.URL || window.webkitURL).createObjectURL(
                img
            );
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        } else if (
            typeof evt.data === 'string' &&
            evt.data.slice(0, 21) === 'data:image/png;base64'
        ) {
            fig.imageObj.src = evt.data;
            fig.updated_canvas_event();
            fig.waiting = false;
            return;
        }

        var msg = JSON.parse(evt.data);
        var msg_type = msg['type'];

        // Call the  "handle_{type}" callback, which takes
        // the figure and JSON message as its only arguments.
        try {
            var callback = fig['handle_' + msg_type];
        } catch (e) {
            console.log(
                "No handler for the '%s' message type: ",
                msg_type,
                msg
            );
            return;
        }

        if (callback) {
            try {
                // console.log("Handling '%s' message: ", msg_type, msg);
                callback(fig, msg);
            } catch (e) {
                console.log(
                    "Exception inside the 'handler_%s' callback:",
                    msg_type,
                    e,
                    e.stack,
                    msg
                );
            }
        }
    };
};

function getModifiers(event) {
    var mods = [];
    if (event.ctrlKey) {
        mods.push('ctrl');
    }
    if (event.altKey) {
        mods.push('alt');
    }
    if (event.shiftKey) {
        mods.push('shift');
    }
    if (event.metaKey) {
        mods.push('meta');
    }
    return mods;
}

/*
 * return a copy of an object with only non-object keys
 * we need this to avoid circular references
 * https://stackoverflow.com/a/24161582/3208463
 */
function simpleKeys(original) {
    return Object.keys(original).reduce(function (obj, key) {
        if (typeof original[key] !== 'object') {
            obj[key] = original[key];
        }
        return obj;
    }, {});
}

mpl.figure.prototype.mouse_event = function (event, name) {
    if (name === 'button_press') {
        this.canvas.focus();
        this.canvas_div.focus();
    }

    // from https://stackoverflow.com/q/1114465
    var boundingRect = this.canvas.getBoundingClientRect();
    var x = (event.clientX - boundingRect.left) * this.ratio;
    var y = (event.clientY - boundingRect.top) * this.ratio;

    this.send_message(name, {
        x: x,
        y: y,
        button: event.button,
        step: event.step,
        buttons: event.buttons,
        modifiers: getModifiers(event),
        guiEvent: simpleKeys(event),
    });

    return false;
};

mpl.figure.prototype._key_event_extra = function (_event, _name) {
    // Handle any extra behaviour associated with a key event
};

mpl.figure.prototype.key_event = function (event, name) {
    // Prevent repeat events
    if (name === 'key_press') {
        if (event.key === this._key) {
            return;
        } else {
            this._key = event.key;
        }
    }
    if (name === 'key_release') {
        this._key = null;
    }

    var value = '';
    if (event.ctrlKey && event.key !== 'Control') {
        value += 'ctrl+';
    }
    else if (event.altKey && event.key !== 'Alt') {
        value += 'alt+';
    }
    else if (event.shiftKey && event.key !== 'Shift') {
        value += 'shift+';
    }

    value += 'k' + event.key;

    this._key_event_extra(event, name);

    this.send_message(name, { key: value, guiEvent: simpleKeys(event) });
    return false;
};

mpl.figure.prototype.toolbar_button_onclick = function (name) {
    if (name === 'download') {
        this.handle_save(this, null);
    } else {
        this.send_message('toolbar_button', { name: name });
    }
};

mpl.figure.prototype.toolbar_button_onmouseover = function (tooltip) {
    this.message.textContent = tooltip;
};

///////////////// REMAINING CONTENT GENERATED BY embed_js.py /////////////////
// prettier-ignore
var _JSXTOOLS_RESIZE_OBSERVER=function(A){var t,i=new WeakMap,n=new WeakMap,a=new WeakMap,r=new WeakMap,o=new Set;function s(e){if(!(this instanceof s))throw new TypeError("Constructor requires 'new' operator");i.set(this,e)}function h(){throw new TypeError("Function is not a constructor")}function c(e,t,i,n){e=0 in arguments?Number(arguments[0]):0,t=1 in arguments?Number(arguments[1]):0,i=2 in arguments?Number(arguments[2]):0,n=3 in arguments?Number(arguments[3]):0,this.right=(this.x=this.left=e)+(this.width=i),this.bottom=(this.y=this.top=t)+(this.height=n),Object.freeze(this)}function d(){t=requestAnimationFrame(d);var s=new WeakMap,p=new Set;o.forEach((function(t){r.get(t).forEach((function(i){var r=t instanceof window.SVGElement,o=a.get(t),d=r?0:parseFloat(o.paddingTop),f=r?0:parseFloat(o.paddingRight),l=r?0:parseFloat(o.paddingBottom),u=r?0:parseFloat(o.paddingLeft),g=r?0:parseFloat(o.borderTopWidth),m=r?0:parseFloat(o.borderRightWidth),w=r?0:parseFloat(o.borderBottomWidth),b=u+f,F=d+l,v=(r?0:parseFloat(o.borderLeftWidth))+m,W=g+w,y=r?0:t.offsetHeight-W-t.clientHeight,E=r?0:t.offsetWidth-v-t.clientWidth,R=b+v,z=F+W,M=r?t.width:parseFloat(o.width)-R-E,O=r?t.height:parseFloat(o.height)-z-y;if(n.has(t)){var k=n.get(t);if(k[0]===M&&k[1]===O)return}n.set(t,[M,O]);var S=Object.create(h.prototype);S.target=t,S.contentRect=new c(u,d,M,O),s.has(i)||(s.set(i,[]),p.add(i)),s.get(i).push(S)}))})),p.forEach((function(e){i.get(e).call(e,s.get(e),e)}))}return s.prototype.observe=function(i){if(i instanceof window.Element){r.has(i)||(r.set(i,new Set),o.add(i),a.set(i,window.getComputedStyle(i)));var n=r.get(i);n.has(this)||n.add(this),cancelAnimationFrame(t),t=requestAnimationFrame(d)}},s.prototype.unobserve=function(i){if(i instanceof window.Element&&r.has(i)){var n=r.get(i);n.has(this)&&(n.delete(this),n.size||(r.delete(i),o.delete(i))),n.size||r.delete(i),o.size||cancelAnimationFrame(t)}},A.DOMRectReadOnly=c,A.ResizeObserver=s,A.ResizeObserverEntry=h,A}; // eslint-disable-line
mpl.toolbar_items = [["Home", "Reset original view", "fa fa-home", "home"], ["Back", "Back to previous view", "fa fa-arrow-left", "back"], ["Forward", "Forward to next view", "fa fa-arrow-right", "forward"], ["", "", "", ""], ["Pan", "Left button pans, Right button zooms\nx/y fixes axis, CTRL fixes aspect", "fa fa-arrows", "pan"], ["Zoom", "Zoom to rectangle\nx/y fixes axis", "fa fa-square-o", "zoom"], ["", "", "", ""], ["Download", "Download plot", "fa fa-floppy-o", "download"]];

mpl.extensions = ["eps", "jpeg", "pgf", "pdf", "png", "ps", "raw", "svg", "tif", "webp"];

mpl.default_extension = "png";/* global mpl */

var comm_websocket_adapter = function (comm) {
    // Create a "websocket"-like object which calls the given IPython comm
    // object with the appropriate methods. Currently this is a non binary
    // socket, so there is still some room for performance tuning.
    var ws = {};

    ws.binaryType = comm.kernel.ws.binaryType;
    ws.readyState = comm.kernel.ws.readyState;
    function updateReadyState(_event) {
        if (comm.kernel.ws) {
            ws.readyState = comm.kernel.ws.readyState;
        } else {
            ws.readyState = 3; // Closed state.
        }
    }
    comm.kernel.ws.addEventListener('open', updateReadyState);
    comm.kernel.ws.addEventListener('close', updateReadyState);
    comm.kernel.ws.addEventListener('error', updateReadyState);

    ws.close = function () {
        comm.close();
    };
    ws.send = function (m) {
        //console.log('sending', m);
        comm.send(m);
    };
    // Register the callback with on_msg.
    comm.on_msg(function (msg) {
        //console.log('receiving', msg['content']['data'], msg);
        var data = msg['content']['data'];
        if (data['blob'] !== undefined) {
            data = {
                data: new Blob(msg['buffers'], { type: data['blob'] }),
            };
        }
        // Pass the mpl event to the overridden (by mpl) onmessage function.
        ws.onmessage(data);
    });
    return ws;
};

mpl.mpl_figure_comm = function (comm, msg) {
    // This is the function which gets called when the mpl process
    // starts-up an IPython Comm through the "matplotlib" channel.

    var id = msg.content.data.id;
    // Get hold of the div created by the display call when the Comm
    // socket was opened in Python.
    var element = document.getElementById(id);
    var ws_proxy = comm_websocket_adapter(comm);

    function ondownload(figure, _format) {
        window.open(figure.canvas.toDataURL());
    }

    var fig = new mpl.figure(id, ws_proxy, ondownload, element);

    // Call onopen now - mpl needs it, as it is assuming we've passed it a real
    // web socket which is closed, not our websocket->open comm proxy.
    ws_proxy.onopen();

    fig.parent_element = element;
    fig.cell_info = mpl.find_output_cell("<div id='" + id + "'></div>");
    if (!fig.cell_info) {
        console.error('Failed to find cell for figure', id, fig);
        return;
    }
    fig.cell_info[0].output_area.element.on(
        'cleared',
        { fig: fig },
        fig._remove_fig_handler
    );
};

mpl.figure.prototype.handle_close = function (fig, msg) {
    var width = fig.canvas.width / fig.ratio;
    fig.cell_info[0].output_area.element.off(
        'cleared',
        fig._remove_fig_handler
    );
    fig.resizeObserverInstance.unobserve(fig.canvas_div);

    // Update the output cell to use the data from the current canvas.
    fig.push_to_output();
    var dataURL = fig.canvas.toDataURL();
    // Re-enable the keyboard manager in IPython - without this line, in FF,
    // the notebook keyboard shortcuts fail.
    IPython.keyboard_manager.enable();
    fig.parent_element.innerHTML =
        '<img src="' + dataURL + '" width="' + width + '">';
    fig.close_ws(fig, msg);
};

mpl.figure.prototype.close_ws = function (fig, msg) {
    fig.send_message('closing', msg);
    // fig.ws.close()
};

mpl.figure.prototype.push_to_output = function (_remove_interactive) {
    // Turn the data on the canvas into data in the output cell.
    var width = this.canvas.width / this.ratio;
    var dataURL = this.canvas.toDataURL();
    this.cell_info[1]['text/html'] =
        '<img src="' + dataURL + '" width="' + width + '">';
};

mpl.figure.prototype.updated_canvas_event = function () {
    // Tell IPython that the notebook contents must change.
    IPython.notebook.set_dirty(true);
    this.send_message('ack', {});
    var fig = this;
    // Wait a second, then push the new image to the DOM so
    // that it is saved nicely (might be nice to debounce this).
    setTimeout(function () {
        fig.push_to_output();
    }, 1000);
};

mpl.figure.prototype._init_toolbar = function () {
    var fig = this;

    var toolbar = document.createElement('div');
    toolbar.classList = 'btn-toolbar';
    this.root.appendChild(toolbar);

    function on_click_closure(name) {
        return function (_event) {
            return fig.toolbar_button_onclick(name);
        };
    }

    function on_mouseover_closure(tooltip) {
        return function (event) {
            if (!event.currentTarget.disabled) {
                return fig.toolbar_button_onmouseover(tooltip);
            }
        };
    }

    fig.buttons = {};
    var buttonGroup = document.createElement('div');
    buttonGroup.classList = 'btn-group';
    var button;
    for (var toolbar_ind in mpl.toolbar_items) {
        var name = mpl.toolbar_items[toolbar_ind][0];
        var tooltip = mpl.toolbar_items[toolbar_ind][1];
        var image = mpl.toolbar_items[toolbar_ind][2];
        var method_name = mpl.toolbar_items[toolbar_ind][3];

        if (!name) {
            /* Instead of a spacer, we start a new button group. */
            if (buttonGroup.hasChildNodes()) {
                toolbar.appendChild(buttonGroup);
            }
            buttonGroup = document.createElement('div');
            buttonGroup.classList = 'btn-group';
            continue;
        }

        button = fig.buttons[name] = document.createElement('button');
        button.classList = 'btn btn-default';
        button.href = '#';
        button.title = name;
        button.innerHTML = '<i class="fa ' + image + ' fa-lg"></i>';
        button.addEventListener('click', on_click_closure(method_name));
        button.addEventListener('mouseover', on_mouseover_closure(tooltip));
        buttonGroup.appendChild(button);
    }

    if (buttonGroup.hasChildNodes()) {
        toolbar.appendChild(buttonGroup);
    }

    // Add the status bar.
    var status_bar = document.createElement('span');
    status_bar.classList = 'mpl-message pull-right';
    toolbar.appendChild(status_bar);
    this.message = status_bar;

    // Add the close button to the window.
    var buttongrp = document.createElement('div');
    buttongrp.classList = 'btn-group inline pull-right';
    button = document.createElement('button');
    button.classList = 'btn btn-mini btn-primary';
    button.href = '#';
    button.title = 'Stop Interaction';
    button.innerHTML = '<i class="fa fa-power-off icon-remove icon-large"></i>';
    button.addEventListener('click', function (_evt) {
        fig.handle_close(fig, {});
    });
    button.addEventListener(
        'mouseover',
        on_mouseover_closure('Stop Interaction')
    );
    buttongrp.appendChild(button);
    var titlebar = this.root.querySelector('.ui-dialog-titlebar');
    titlebar.insertBefore(buttongrp, titlebar.firstChild);
};

mpl.figure.prototype._remove_fig_handler = function (event) {
    var fig = event.data.fig;
    if (event.target !== this) {
        // Ignore bubbled events from children.
        return;
    }
    fig.close_ws(fig, {});
};

mpl.figure.prototype._root_extra_style = function (el) {
    el.style.boxSizing = 'content-box'; // override notebook setting of border-box.
};

mpl.figure.prototype._canvas_extra_style = function (el) {
    // this is important to make the div 'focusable
    el.setAttribute('tabindex', 0);
    // reach out to IPython and tell the keyboard manager to turn it's self
    // off when our div gets focus

    // location in version 3
    if (IPython.notebook.keyboard_manager) {
        IPython.notebook.keyboard_manager.register_events(el);
    } else {
        // location in version 2
        IPython.keyboard_manager.register_events(el);
    }
};

mpl.figure.prototype._key_event_extra = function (event, _name) {
    // Check for shift+enter
    if (event.shiftKey && event.which === 13) {
        this.canvas_div.blur();
        // select the cell after this one
        var index = IPython.notebook.find_cell_index(this.cell_info[0]);
        IPython.notebook.select(index + 1);
    }
};

mpl.figure.prototype.handle_save = function (fig, _msg) {
    fig.ondownload(fig, null);
};

mpl.find_output_cell = function (html_output) {
    // Return the cell and output element which can be found *uniquely* in the notebook.
    // Note - this is a bit hacky, but it is done because the "notebook_saving.Notebook"
    // IPython event is triggered only after the cells have been serialised, which for
    // our purposes (turning an active figure into a static one), is too late.
    var cells = IPython.notebook.get_cells();
    var ncells = cells.length;
    for (var i = 0; i < ncells; i++) {
        var cell = cells[i];
        if (cell.cell_type === 'code') {
            for (var j = 0; j < cell.output_area.outputs.length; j++) {
                var data = cell.output_area.outputs[j];
                if (data.data) {
                    // IPython >= 3 moved mimebundle to data attribute of output
                    data = data.data;
                }
                if (data['text/html'] === html_output) {
                    return [cell, data, j];
                }
            }
        }
    }
};

// Register the function which deals with the matplotlib target/channel.
// The kernel may be null if the page has been refreshed.
if (IPython.notebook.kernel !== null) {
    IPython.notebook.kernel.comm_manager.register_target(
        'matplotlib',
        mpl.mpl_figure_comm
    );
}

</script></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<div id='536f617e-6eeb-48a5-a43d-312df8a0edb5'></div></div>
</div>
<section id="Other-observables">
<h3>Other observables<a class="headerlink" href="#Other-observables" title="Link to this heading"></a></h3>
<p>The same applies for the observables, such as the pair distribution function <span class="math notranslate nohighlight">\(G(r)\)</span>. To determine how to calculate another observables from an MD trajectory, please see the associated help documentation:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">help</span><span class="p">(</span><span class="n">observables</span><span class="o">.</span><span class="n">PDF</span><span class="o">.</span><span class="n">calculate_from_MD</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on function calculate_from_MD in module MDMC.trajectory_analysis.observables.pdf:

calculate_from_MD(self, MD_input: MDMC.trajectory_analysis.compact_trajectory.CompactTrajectory, verbose: int = 0, **settings: dict)
    Calculate the pair distribution function, :math:`G(r)` from a ``CompactTrajectory``.

    The partial pair distribution (from __) for a pair i-j, :math:`g_{ij}`, is:

    .. math::

        g_{ij}(r) = \frac{h_{ij}(r)}{4 \pi r^2 \rho_{j} \Delta{r}}

    where :math:`h_{ij}`` is the histogram of distances of :math:`j` element
    atoms around atoms of element :math:`i`, with bins of size
    :math:`\Delta{r}`, and :math:`\rho_{j}` is the number density of
    atoms of element :math:`j`. As :math:`g_{ij}(0) = 0`, it is evident that
    :math:`G(0) = -\sum\limits_{i,j}^{N_{elements}} c_ic_jb_ib_j`.

    The total pair distribution function (``pdf.PDF``) has the form:

    .. math::

        G(r) = \sum_{i,j}^{N_{elements}} c_ic_jb_ib_j(g_{ij}(r) - 1)

    where :math:`c_i` is the proportion of element :math:`i` in the material,
    :math:`b_i` is the (coherent) scattering length of element :math:`i`

    This corresponds to the equation (10) in the above paper.

    Independent variables can either be set previously or defined within
    settings.

    A number of frames can be specified, from which the ``PDF`` and its
    error are calculated. If the number of frames is too large relative to
    the run length, the samples will be correlated, which will result in an
    underestimate of the error.

    Parameters
    ----------
    MD_input : CompactTrajectory
        A single ``CompactTrajectory`` object.
    verbose : int
        Verbose print settings. Not currently implemented for PDF.
    **settings
        Extra options.

    Other Parameters
    ----------------
    n_frames : int
        The number of frames from which the PDF and its error are
        calculated. These frames are selected uniformly, and the
        step is taken to be n_frames / total number of frames
        rounded to the nearest positive integer.

        If this is not passed, 1% of the total number of frames
        are used (rounded up).
    use_average : bool
        If set to `False` (default), only the last frame of the
        trajectory is used and n_frames will be ignored.

        If set to `True` then the mean value for PDF is calculated
        across selected frames from the trajectory. Also, the
        errors are set to the standard deviation calculated over
        the multiple frames.
    subset : list of tuples
        The subset of element pairs from which the PDF is calculated.

        This can be used to calculate the partial PDFs of a
        multicomponent system. If this is not passed, all combinations
        of elements are used i.e. the PDF is the total PDF.
    b_coh : dict
        A dictionary containing coherent scattering length values
        for one or more elements.

        This can be used to calculate
        the PDF of a system where one or more elements has a
        coherent scattering length different from the coherent
        scattering lengths from ``periodictable``.
    r_min : float
        The minimum ``r`` (atomic separation) in Angstrom for
        which the PDF will be calculated.
    r_max : float
        The maximum ``r`` (atomic separation) in Angstrom for
        which the PDF will be calculated.
    r_step : float
        The step size of ``r`` (atomic separation) for which the PDF
        will be calculated.
    r : numpy.ndarray
        The uniform ``r`` values in Angstrom for which the PDF
        will be calculated.
    dimensions : array-like
        A 3 element `array-like` (`list`, `tuple`) with the
        dimensions of the ``Universe`` in Angstrom.

    Notes
    -----
    If this, ``r_min``, ``r_max``, and ``r_step`` are passed then these
    will create a range for the independent variable ``r``,
    which will overwrite any ``r`` which has previously been
    defined. These cannot be passed if ``r`` is passed.

    Examples
    --------
    To calculate the O-O partial PDF from a simulation of water, use the
    subset keyword:

    .. code-block:: python

        pdf.calculate_from_MD(trajectory, subset=[(O, O)])

    To calculate the sum of the H-O and O-O partial PDFs:

    .. code-block:: python

        pdf.calculate_from_MD(trajectory, subset=[(O, O), (H, O)])

    To calculate the total PDF for sodium chloride with 37Cl:

    .. code-block:: python

        pdf.calculate_from_MD(trajectory, b_coh={&#39;Cl&#39;:3.08})

    To calculate the total PDF for r values of [1., 2., 3., 4.]:

    .. code-block:: python

        pdf.calculate_from_MD(trajectory, r=[1., 2., 3., 4.])

    To calculate the total PDF over an average of 5 frames:

    .. code-block:: python

        pdf.calculate_from_MD(trajectory, use_average=True, n_frames=5)

</pre></div></div>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="running-a-simulation.html" class="btn btn-neutral float-left" title="Running a Simulation in MDMC" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../parameter-refinement.html" class="btn btn-neutral float-right" title="Parameter Refinement" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>