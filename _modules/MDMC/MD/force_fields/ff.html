<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MDMC.MD.force_fields.ff &mdash; MDMC 0.2 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> MDMC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/installation.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/simulations.html">3. Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/parameter-refinement.html">4. Parameter Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/contributing.html">5. Contributing to MDMC</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/building-a-universe.html">Building an MDMC Universe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/read-configurations.html">Reading atoms from configuration files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/units.html">Units in MDMC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/applying-a-forcefield.html">Applying a <code class="docutils literal notranslate"><span class="pre">ForceField</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/solvating-a-universe.html">Solvating an MDMC Universe</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/molecular-visualization.html">Molecular Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/running-a-simulation.html">Running a Simulation in MDMC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/creating-an-observable.html">Creating an Observable from a Simulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/selecting-fitting-parameters.html">Selecting Fitting Parameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/running-a-refinement.html">Running a Refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/Argon-a-to-z.html">Argon A-to-Z</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Developer Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/coding_standards.html">Coding Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/documentation.html">Documentation Standards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/units.html">Units</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/testing.html">Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/management.html">MDMC Software Management</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/containers.html">Containers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/developer/vscode.html">Debugging inside Containers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/common.html">common</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/control.html">control</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/gui.html">gui</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/md.html">MD</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/readers.html">readers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/refinement.html">refinement</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../pages/modules/trajectory_analysis.html">trajectory_analysis</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MDMC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>MDMC.MD.force_fields.ff</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for MDMC.MD.force_fields.ff</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;A module for defining force fields that can be applied to a universe</span>

<span class="sd">Each force field consists of a combination of interaction functions, and also</span>
<span class="sd">the values of the parameters within these functions.  In this instance water</span>
<span class="sd">models (such as SPCE and TIP3P) are also defined as force fields, even though</span>
<span class="sd">the parameter sets are restricted to describing water.  Each force field module</span>
<span class="sd">is self contained, although adding a new force field may require changes to the</span>
<span class="sd">MD engine facades, so that a correspondence is established between the MDMC</span>
<span class="sd">force field and the MD engine equivalent.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">lru_cache</span>
<span class="kn">from</span> <span class="nn">inspect</span> <span class="kn">import</span> <span class="n">signature</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span><span class="p">,</span> <span class="n">permutations</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">re</span> <span class="kn">import</span> <span class="n">escape</span><span class="p">,</span> <span class="n">sub</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="kn">from</span> <span class="nn">MDMC.common.decorators</span> <span class="kn">import</span> <span class="n">repr_decorator</span>
<span class="kn">from</span> <span class="nn">MDMC.common.df_operations</span> <span class="kn">import</span> <span class="n">filter_dataframe</span><span class="p">,</span> <span class="n">filter_ordered_dataframe</span>
<span class="kn">from</span> <span class="nn">MDMC.MD.interactions</span> <span class="kn">import</span> <span class="n">Coulombic</span><span class="p">,</span> <span class="n">BondedInteraction</span>
<span class="kn">from</span> <span class="nn">MDMC.MD</span> <span class="kn">import</span> <span class="n">interaction_functions</span>


<span class="n">LOGGER</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="ForceField"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.ForceField">[docs]</a><span class="nd">@repr_decorator</span><span class="p">(</span><span class="s1">&#39;interaction_dictionary&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ForceField</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class defining a force field</span>

<span class="sd">    For each interaction type that it uses (non-bonded, bonds, bond angles etc),</span>
<span class="sd">    a force field must define the interaction function (LJ, harmonic etc).  It</span>
<span class="sd">    must also define the parameters for each of these functions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">interaction_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The `dict` of interactions that exist within the ``ForceField``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            {``Interaction``:``Elements``} where ``Elements`` is an ordered</span>
<span class="sd">            `tuple` of elemental symbols, and values of ``InteractionFunction``</span>
<span class="sd">            objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

<div class="viewcode-block" id="ForceField.parameterize_interactions"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.ForceField.parameterize_interactions">[docs]</a>    <span class="k">def</span> <span class="nf">parameterize_interactions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interactions</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes the interactions with the parameters speicifed in the</span>
<span class="sd">        ``interaction`` `dict`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interactions : list</span>
<span class="sd">            A `list` of ``Interaction`` objects to be parameterized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">interactions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parameterize_interaction</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_parameterize_interaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interaction</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes the interaction with the parameters specified in the</span>
<span class="sd">        ``interaction`` `dict`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interaction : Interaction</span>
<span class="sd">            An ``Interaction`` to be parameterized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">elements</span> <span class="o">=</span> <span class="n">interaction</span><span class="o">.</span><span class="n">element_tuple</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">interaction</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interaction_dictionary</span><span class="p">[</span>
                <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">interaction</span><span class="p">),</span> <span class="n">elements</span><span class="p">)]</span>
            <span class="n">interaction</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">set_parameters_interactions</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;This force field does not have defined interactions&quot;</span>
                           <span class="s2">&quot; for these element types&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="WaterModel"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.WaterModel">[docs]</a><span class="nd">@repr_decorator</span><span class="p">(</span><span class="s1">&#39;interaction_dictionary&#39;</span><span class="p">,</span> <span class="s1">&#39;n_body&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">WaterModel</span><span class="p">(</span><span class="n">ForceField</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class for force fields that describe a water model</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">n_body</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the number of bodies in the water model.</span>

<span class="sd">        .. note:: THIS MUST BE IMPLEMENTED USING A STATIC VARIABLE, INSTEAD OF A</span>
<span class="sd">                  PROPERTY.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The number of bodies (atoms) in the water model.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="FileForceField"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.FileForceField">[docs]</a><span class="nd">@repr_decorator</span><span class="p">(</span><span class="s1">&#39;file_name&#39;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">FileForceField</span><span class="p">(</span><span class="n">ForceField</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract class for force fields that are read from files</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absolute_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">n_datatypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_header</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">(),</span> <span class="nb">int</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse_header</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">(),</span>
                                                           <span class="nb">str</span><span class="p">))</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">while</span> <span class="s1">&#39;Atoms&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">n_datatypes</span><span class="p">:</span>
                <span class="c1"># +1 rows to account for header</span>
                <span class="n">datatype</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">num</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;python&#39;</span><span class="p">,</span>
                                       <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;atoms&#39;</span>
                                                           <span class="k">else</span> <span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;str&#39;</span><span class="p">)</span>
                <span class="c1"># Convert columns to correct types</span>
                <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">datatype</span><span class="p">:</span>
                    <span class="n">datatype</span><span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_col_type</span><span class="p">(</span><span class="n">datatype</span><span class="p">[</span><span class="n">col_name</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">datatype</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">atom_name_group</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">element</span><span class="p">),</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">atom_group</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_type_name</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">atom_type</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">absolute_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the absolute path of the data</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The absolute path (including file name) of the force field data file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Either the file name is defined with the path, in which case it is the</span>
        <span class="c1"># same as the absolute path</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span>
        <span class="c1"># Or it is assumed that the path is the force field data directory</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
                <span class="o">+</span> <span class="s1">&#39;/data/&#39;</span>
                <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">file_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the file name of the data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the atoms defined within the force field</span>

<span class="sd">        May includes the normal number of bonds that this atom type should</span>
<span class="sd">        possess, which is not currently used but could be an additional check on</span>
<span class="sd">        the validity of the topology</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with the force field atom type, atom group, element,</span>
<span class="sd">            mass, charge, and name</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bonds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the bonds of the force field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with all bonds, atom groups, and the parameters of</span>
<span class="sd">            the bonds</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;bonds&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bond_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the bond angles of the force field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with all bond angles, atom groups, and the</span>
<span class="sd">            parameters of the bond angle</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;bondangles&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">propers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the proper dihedrals of the force field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with all proper dihedrals, atom groups, and the</span>
<span class="sd">            parameters of the proper dihedral</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;propers&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">impropers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the improper dihedrals of the force field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with all improper dihedrals, atom groups, and the</span>
<span class="sd">            parameters of the improper dihedral</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;impropers&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dispersions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get file parameters for the dispersion interactions of the force field</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A ``DataFrame`` with all dispersion interactions, atom types, and</span>
<span class="sd">            the parameters of the dispersion interaction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dispersions&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">interaction_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Cache interaction dictionary</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interaction_dictionary</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_interaction_dictionary</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_interaction_dictionary</span>

<div class="viewcode-block" id="FileForceField.filter_element"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.FileForceField.filter_element">[docs]</a>    <span class="k">def</span> <span class="nf">filter_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the atoms in the ``FileForceField`` by element</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        element : str</span>
<span class="sd">            The element by which the atoms in the FileForceField will be</span>
<span class="sd">            filtered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A filtered ``DataFrame`` where each row is an atom type that has an</span>
<span class="sd">            element specified by ``element``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">filter_dataframe</span><span class="p">([</span><span class="n">element</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;element&#39;</span><span class="p">])</span></div>

<div class="viewcode-block" id="FileForceField.set_atom_mass"><a class="viewcode-back" href="../../../../pages/modules/md/force_fields/ff.html#MDMC.MD.force_fields.ff.FileForceField.set_atom_mass">[docs]</a>    <span class="k">def</span> <span class="nf">set_atom_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets ``Atom.mass`` to the mass defined in the force field for that atom</span>
<span class="sd">        type</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            The ``Atom`` for which the mass will be set</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ff_atom</span> <span class="o">=</span> <span class="n">filter_ordered_dataframe</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                           <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;element&#39;</span><span class="p">])</span>
        <span class="n">atom</span><span class="o">.</span><span class="n">mass</span> <span class="o">=</span> <span class="n">ff_atom</span><span class="o">.</span><span class="n">mass</span></div>

    <span class="k">def</span> <span class="nf">_parameterize_interaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interaction</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameterizes the interaction with the parameters specified in the</span>
<span class="sd">        ``interaction`` `dict`</span>

<span class="sd">        Arguments:</span>
<span class="sd">        interaction : Interaction</span>
<span class="sd">            An ``Interaction`` to be parameterized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interaction</span><span class="p">,</span> <span class="n">BondedInteraction</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parametrize_bonded</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interaction</span><span class="p">,</span> <span class="n">Coulombic</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parametrize_coulombic</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parametrize_dispersion</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parametrize_bonded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bonded</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parametrizes a ``BondedInteraction``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bonded : BondedInteraction</span>
<span class="sd">            A subclass of ``BondedInteraction`` which will be parametrized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom_tuple</span> <span class="ow">in</span> <span class="n">bonded</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">tuple_groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atom_tuple</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_convert_atom_type_name</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                <span class="c1"># Raise an error if the name/element combination can&#39;t be found</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tuple_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atom_name_group</span><span class="p">[(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                                              <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">)])</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Unable to find atom of element &quot;</span><span class="si">{0}</span><span class="s1">&quot; recorded with&#39;</span>
                           <span class="s1">&#39; the name &quot;</span><span class="si">{1}</span><span class="s1">&quot; in the specified force field file.&#39;</span>
                           <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">error</span>

            <span class="n">groups</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">tuple_groups</span><span class="p">))</span>

        <span class="c1"># Ensure that the groups of all atom tuples is consistent (i.e. each</span>
        <span class="c1"># atom tuple should contain the same groups, in the same order)</span>
        <span class="c1"># It is important to note that this is more restrictive than it needs to</span>
        <span class="c1"># be - it could allow not raise an error where the mismatch was valid</span>
        <span class="c1"># because wildcards would allow the interaction parameters to be the</span>
        <span class="c1"># same regardless of the different atom groups, however this is not</span>
        <span class="c1"># implemented.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The atom groups of this interaction are not consistent </span><span class="si">{0}</span><span class="s1">.&#39;</span>
                   <span class="s1">&#39; Atom tuples should have the same groups in the same&#39;</span>
                   <span class="s1">&#39; order.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">groups</span><span class="p">))</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                         <span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">groups</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">bonded_type</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">bonded</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bonded_type</span> <span class="o">==</span> <span class="s1">&#39;DihedralAngle&#39;</span><span class="p">:</span>
            <span class="n">bonded_type</span> <span class="o">=</span> <span class="s1">&#39;improper&#39;</span> <span class="k">if</span> <span class="n">bonded</span><span class="o">.</span><span class="n">improper</span> <span class="k">else</span> <span class="s1">&#39;proper&#39;</span>
        <span class="n">function_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interaction_function</span><span class="p">(</span><span class="n">bonded_type</span><span class="p">)</span>

        <span class="n">parameter_df</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sub</span><span class="p">(</span><span class="s1">&#39;(?&lt;!^)(?=[A-Z])&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;_&#39;</span><span class="p">,</span>
                                         <span class="n">bonded_type</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s1">&#39;s&#39;</span><span class="p">)</span>

        <span class="c1"># Filter for both the specified order of groups, and the reverse</span>
        <span class="c1"># This is valid for all bonded types except improper dihedrals, which</span>
        <span class="c1"># for which only the first atom occupies a unique position (the center);</span>
        <span class="c1"># the other atoms can be in any permutation</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">bonded_type</span> <span class="o">!=</span> <span class="s1">&#39;improper&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ordered_groups</span> <span class="ow">in</span> <span class="p">[</span><span class="n">groups</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">groups</span><span class="p">))]:</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="s1">&#39;atom_group?&#39;</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_ordered_dataframe</span><span class="p">(</span><span class="n">ordered_groups</span><span class="p">,</span>
                                                        <span class="n">parameter_df</span><span class="p">,</span>
                                                        <span class="n">column_regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                                                        <span class="n">wildcard</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">col_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;atom_group1&#39;</span><span class="p">]</span>
            <span class="n">cen_atom_match</span> <span class="o">=</span> <span class="n">filter_ordered_dataframe</span><span class="p">([</span><span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                                      <span class="n">parameter_df</span><span class="p">,</span>
                                                      <span class="n">column_names</span><span class="o">=</span><span class="n">col_names</span><span class="p">,</span>
                                                      <span class="n">wildcard</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">permuted_groups</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">permutations</span><span class="p">(</span><span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
                <span class="c1"># Only filter using atom_group2, atom_group3, atom_group4</span>
                <span class="n">regex</span> <span class="o">=</span> <span class="s1">&#39;^atom_group[2-4]$&#39;</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_ordered_dataframe</span><span class="p">(</span><span class="n">permuted_groups</span><span class="p">,</span>
                                                        <span class="n">cen_atom_match</span><span class="p">,</span>
                                                        <span class="n">column_regex</span><span class="o">=</span><span class="n">regex</span><span class="p">,</span>
                                                        <span class="n">wildcard</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Duplicate dropping requied for groups == tuple(reversed(groups))</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">()</span>
        <span class="c1"># If there is more than one row which matches the groups (because of</span>
        <span class="c1"># wildcards) then pick row with fewest wildcards</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">matching_group</span> <span class="o">=</span> <span class="n">matches</span><span class="o">.</span><span class="n">loc</span><span class="p">[[(</span><span class="n">matches</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">regex</span><span class="o">=</span><span class="s1">&#39;atom_group?&#39;</span><span class="p">)</span>
                                           <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;columns&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()]]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">matching_group</span> <span class="o">=</span> <span class="n">matches</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If there are no matches in the file, then raise an error</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Unable to find bond information for specified atoms: &#39;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">groups</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">&#39;atom_group</span><span class="si">{0}</span><span class="s1"> - </span><span class="si">{1}</span><span class="s1"> (</span><span class="si">{2}</span><span class="s1">), &#39;</span>
                        <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">atom_type</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">atom_type_name</span><span class="p">[</span><span class="n">atom_type</span><span class="p">]))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Get the parameter names for the InteractionFunction. This means that</span>
        <span class="c1"># the columns in the bonded DataFrame do not need to be ordered,</span>
        <span class="c1"># as long as the column names are the same as the InteractionFunction</span>
        <span class="c1"># parameter names (e.g. equilibrium_state and potential_strength must</span>
        <span class="c1"># exist in self.bonds if it is a HarmonicPotential, but can be in any</span>
        <span class="c1"># order).</span>
        <span class="n">parameter_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parameter_names</span><span class="p">(</span><span class="n">function_type</span><span class="p">,</span>
                                                    <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span>
                                                     <span class="ow">in</span> <span class="n">matching_group</span> <span class="k">if</span>
                                                     <span class="s1">&#39;atom_group&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">name</span><span class="p">])</span>

        <span class="n">settings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">function_type</span> <span class="o">==</span> <span class="n">interaction_functions</span><span class="o">.</span><span class="n">HarmonicPotential</span><span class="p">:</span>
            <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;interaction_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bonded_type</span>
        <span class="c1"># As parameter_names is correctly sorted</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">matching_group</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span>
                      <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_interaction_function</span><span class="p">(</span><span class="n">bonded</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span>
                                       <span class="n">settings</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parametrize_coulombic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coulombic</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assumes that all force fields have a ``Coulomb`` ``InteractionFunction``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coulombic : Coulombic</span>
<span class="sd">            The ``Coulombic`` to be parametrized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check we have atoms to apply interaction to</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coulombic</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Unable to find any atoms of types </span><span class="si">{}</span><span class="s1"> in the Universe to &#39;</span>
                   <span class="s1">&#39;apply the Coulombic interaction to&#39;</span>
                   <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">coulombic</span><span class="o">.</span><span class="n">atom_types</span><span class="p">))</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Different atom names could be defined within the same coulombic</span>
        <span class="c1"># Both atom name and element are required to uniquely identify the atom</span>
        <span class="n">atom_names_elements</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">coulombic</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_convert_atom_type_name</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">atom_names_elements</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">element</span><span class="p">))</span>

        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;element&#39;</span><span class="p">]</span>
        <span class="n">matching_atoms</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">filter_ordered_dataframe</span><span class="p">(</span><span class="n">name_element</span><span class="p">,</span>
                                                             <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                                             <span class="n">column_names</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">name_element</span> <span class="ow">in</span> <span class="n">atom_names_elements</span><span class="p">])</span>
        <span class="c1"># Check that charges for all atom names are the same</span>
        <span class="n">unique_charges</span> <span class="o">=</span> <span class="n">matching_atoms</span><span class="o">.</span><span class="n">charge</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nonbonded_parameters</span><span class="p">(</span><span class="n">unique_charges</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;charge&#39;</span><span class="p">],</span>
                                         <span class="n">matching_atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_charges</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If not, show the corresponding atom rows in the error message</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;All atoms of the Coulombic interaction must have the same&#39;</span>
                   <span class="s1">&#39; OPLS charge (</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matching_atoms</span><span class="p">))</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                         <span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_interaction_function</span><span class="p">(</span><span class="n">coulombic</span><span class="p">,</span>
                                       <span class="n">interaction_functions</span><span class="o">.</span><span class="n">Coulomb</span><span class="p">,</span>
                                       <span class="n">unique_charges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_parametrize_dispersion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dispersion</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        While dispersion interactions can be defined between unlike atom types,</span>
<span class="sd">        this is not the case for any major force field implementation (e.g.</span>
<span class="sd">        OPLS, CHARMM, AMBER). Therefore currently this only parametrizes</span>
<span class="sd">        like-like dispersion interactions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dispersion : Dispersion</span>
<span class="sd">            The ``Dispersion`` to be parametrized</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># As the atoms in a dispersion are determined by dispersion.atom_type,</span>
        <span class="c1"># each atom pair must be consistent (i.e. it is only necessary to</span>
        <span class="c1"># consider two atoms from each pair as they will be the same as all</span>
        <span class="c1"># other atoms in the pair)</span>

        <span class="n">matching_disps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">atom_pairs</span> <span class="ow">in</span> <span class="n">dispersion</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="c1"># Checks that atom_pairs are like-like and that we have atoms to</span>
            <span class="c1"># apply interaction to</span>
            <span class="n">atom_pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">atom_pairs</span><span class="p">)</span>
            <span class="n">atom_pair</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom_type_pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom_pairs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom_type_pair</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">existing_types</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dispersion</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">atom_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">existing_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;No atoms of type &quot;</span><span class="si">{0}</span><span class="s1">&quot; found, the Universe &#39;</span>
                           <span class="s1">&#39;contains only the types </span><span class="si">{1}</span><span class="s1">&#39;</span>
                           <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dispersion</span><span class="o">.</span><span class="n">atom_types</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span>
                                     <span class="n">existing_types</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

                <span class="n">atom_pair</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_type_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">atom_pair</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Currently only force fields which only use like-like&#39;</span>
                       <span class="s1">&#39; Dispersion terms are implemented&#39;</span><span class="p">)</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">: {atom_pair: </span><span class="si">%s</span><span class="s1">}. </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                             <span class="n">atom_pair</span><span class="p">,</span>
                             <span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># As only like-like, just consider first index of atom_pairs</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atom_pairs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_convert_atom_type_name</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="c1"># As all atoms within atom_pairs should be the same, only consider</span>
            <span class="c1"># single atom when determining ff_atom_type</span>
            <span class="c1"># ff_atom_type is different to MDMC atom_type</span>
            <span class="n">atom_name_element</span> <span class="o">=</span> <span class="p">(</span><span class="n">atom_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">atom_pairs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">element</span><span class="p">)</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;element&#39;</span><span class="p">]</span>
            <span class="n">ff_atom_type</span> <span class="o">=</span> <span class="n">filter_ordered_dataframe</span><span class="p">(</span><span class="n">atom_name_element</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                                    <span class="n">column_names</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span><span class="o">.</span><span class="n">atom_type</span>
            <span class="n">matching_disps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filter_dataframe</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">ff_atom_type</span><span class="p">),</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">dispersions</span><span class="p">,</span>
                                                   <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;atom_type&#39;</span><span class="p">]))</span>
        <span class="n">matching_disps</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">matching_disps</span><span class="p">)</span>

        <span class="n">function_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_interaction_function</span><span class="p">(</span><span class="s1">&#39;dispersion&#39;</span><span class="p">)</span>
        <span class="n">parameter_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parameter_names</span><span class="p">(</span><span class="n">function_type</span><span class="p">)</span>

        <span class="n">unique_parameters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">([</span><span class="n">matching_disps</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
                                                      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">parameter_names</span><span class="p">])</span>
                                <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_nonbonded_parameters</span><span class="p">(</span><span class="n">unique_parameters</span><span class="p">,</span> <span class="n">parameter_names</span><span class="p">,</span>
                                         <span class="n">matching_disps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_interaction_function</span><span class="p">(</span><span class="n">dispersion</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span>
                                       <span class="n">unique_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_interaction_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interaction_type</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the ``InteractionFunction`` for the corresponding ``Interaction``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interaction_type : str</span>
<span class="sd">            A `str` specifying an interaction type, which must be a key in</span>
<span class="sd">            ``self._inter_functions``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        InteractionFunction</span>
<span class="sd">            The subclass of ``InteractionFunction`` correspoding to</span>
<span class="sd">            ``interaction_type``</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">function_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter_functions</span><span class="p">[</span><span class="n">interaction_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">interaction_functions</span><span class="p">,</span> <span class="n">function_name</span><span class="p">)</span>


    <span class="nd">@lru_cache</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_convert_atom_type_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts all ``Atom`` objects with ``Atom.name`` that are a valid force</span>
<span class="sd">        field type (i.e. can be cast to an `int`) into the corresponding force</span>
<span class="sd">        field atom name.</span>

<span class="sd">        Each ``Atom.name`` only needs to be converted once, however they will be</span>
<span class="sd">        converted for every interaction in which they appear - avoid this with</span>
<span class="sd">        lrucache</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : Atom</span>
<span class="sd">            The ``Atom`` for which the name will be converted</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the ``Atom`` does not have a valid force field type or a force</span>
<span class="sd">            field atom name, raise a ValueError. This atom cannot be interpreted</span>
<span class="sd">            as valid within the force field.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># int cast as atom names will be strings, even if they are numerical</span>
        <span class="c1"># (e.g. an atom type)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_type_name</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>

            <span class="c1"># Check if atom.name is already a name in the atoms DataFrame</span>
            <span class="k">if</span> <span class="n">filter_dataframe</span><span class="p">([</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span>
                                <span class="n">column_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;All atom names must be an OPLS atom type or an OPLS&#39;</span>
                       <span class="s1">&#39; atom name. </span><span class="si">{0}</span><span class="s1"> is not an OPLS atom type of atom&#39;</span>
                       <span class="s1">&#39; name.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
                             <span class="n">msg</span><span class="p">,</span>
                             <span class="n">exc_info</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_parameter_names</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">file_parameter_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the names of the parameters of function, excluding ``self`` and</span>
<span class="sd">        ``**settings``</span>

<span class="sd">        If ``*args`` is included in the function signature, then the parameter</span>
<span class="sd">        names are taken from the file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function : callable</span>
<span class="sd">            Any callable (e.g. function, method)</span>
<span class="sd">        file_parameter_names : list</span>
<span class="sd">            `list` of `str` with the parameter names from the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `list` of `str`</span>
<span class="sd">            The parameters of the function</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the function signature has ``*args`` and the parameter names in</span>
<span class="sd">            the file are incorrectly ordered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># VAR_POSITIONAL is the Python Parameter kind which is used for *args</span>
        <span class="n">var_positional</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">parameter_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">function_parameters</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">(</span><span class="n">function</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="c1"># Test that the kind of parameter is a VAR_POSITIONAL</span>
            <span class="k">if</span> <span class="n">function_parameters</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">function_parameters</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">var_positional</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">function_parameters</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;settings&#39;</span><span class="p">]:</span>
                    <span class="n">parameter_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">var_positional</span><span class="p">:</span>
            <span class="c1"># If there is *args in the function signature, we cannot determine</span>
            <span class="c1"># the parameter names. Check that the parameter names in the</span>
            <span class="c1"># signature agree with the order of the parameter names in the file.</span>
            <span class="c1"># If this is the case, assume file parameter names are correctly</span>
            <span class="c1"># ordered and use these, otherwise raise a ValueError</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">parameter_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">file_parameter_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span>
                    <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">))]):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;The force field data file has incorrectly ordered </span><span class="si">{0}</span><span class="s1">&#39;</span>
                       <span class="s1">&#39; parameters&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">parameter_names</span><span class="p">))</span>
                <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;FileForceField: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                             <span class="n">msg</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">parameter_names</span> <span class="o">=</span> <span class="n">file_parameter_names</span>

        <span class="k">return</span> <span class="n">parameter_names</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_nonbonded_parameters</span><span class="p">(</span><span class="n">function_parameters</span><span class="p">,</span>
                                    <span class="n">function_parameter_names</span><span class="p">,</span>
                                    <span class="n">matching_inters</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks that the parameters for an ``InteractionFunction`` for a</span>
<span class="sd">        ``NonBondedInteraction`` are valid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        function_parameters : list</span>
<span class="sd">            The parameters which will be passed to an ``InteractionFunction``</span>
<span class="sd">        function_parameter_names : list</span>
<span class="sd">            A list of the names of the ``function_parameters``</span>
<span class="sd">        matching_inters : pandas.DataFrame</span>
<span class="sd">            A ``Dataframe`` of the lines of the interaction in the force field</span>
<span class="sd">            file which match the ``NonBondedInteraction`` which is being</span>
<span class="sd">            parametrized</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If atoms which have been added to the ``NonBondedInteraction`` do</span>
<span class="sd">            not have the same ``InteractionFunction`` parameters for the force</span>
<span class="sd">            field, they cannot be included in the same ``NonBondedInteraction``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">function_parameters</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">function_parameter_names</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;All atoms of the interaction must have the same OPLS&#39;</span>
                   <span class="s1">&#39; parameters (</span><span class="si">{0}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matching_inters</span><span class="p">))</span>
            <span class="n">LOGGER</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;FileForceField: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="n">msg</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_interaction_function</span><span class="p">(</span><span class="n">interaction</span><span class="p">,</span> <span class="n">function_type</span><span class="p">,</span>
                                  <span class="n">function_parameters</span><span class="p">,</span> <span class="n">function_settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialises an ``InteractionFunction`` with specified parameters and</span>
<span class="sd">        settings and sets it for an ``Interaction``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interaction : Interaction</span>
<span class="sd">            The ``Interaction`` for which the ``InteractionFunction`` will be</span>
<span class="sd">            set</span>
<span class="sd">        function_type : InteractionFunction class</span>
<span class="sd">            The ``InteractionFunction`` class which will be initialised</span>
<span class="sd">        function_parameters : list</span>
<span class="sd">            The parameters which are passed to the ``function_type``</span>
<span class="sd">        function_settings : dict, optional</span>
<span class="sd">            Any ``**settings`` to be passed to the ``function_type`` for</span>
<span class="sd">            initialising. The default is `None`, which results in no</span>
<span class="sd">            ``**settings`` being passed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">function_settings</span> <span class="o">=</span> <span class="n">function_settings</span> <span class="k">if</span> <span class="n">function_settings</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">interaction</span><span class="o">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">function_type</span><span class="p">(</span><span class="o">*</span><span class="n">function_parameters</span><span class="p">,</span>
                                             <span class="o">**</span><span class="n">function_settings</span><span class="p">)</span>
        <span class="n">interaction</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="n">set_parameters_interactions</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_parse_header</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a force field file header line</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        header : str</span>
<span class="sd">            The header line to be parsed</span>
<span class="sd">        dtype : class</span>
<span class="sd">            The expected datatype of the ``header`` parameters, e.g. `int` or</span>
<span class="sd">            `str`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list of tuples</span>
<span class="sd">            (``keyword``, ``parameter``) where ``keyword`` is a `str` which</span>
<span class="sd">            specifies a force field file section, and ``parameter`` is the</span>
<span class="sd">            description associated with it.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Strip newline formatting</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">name</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">dtype</span><span class="p">(</span><span class="n">parameter</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)))</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)]]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_col_type</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the type of a ``DataFrame`` column to either a `float` or an `int`,</span>
<span class="sd">        if possible</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        column : pandas.Series</span>
<span class="sd">            The column for which the type will be converted</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">escape</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">column</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">column</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">column</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>